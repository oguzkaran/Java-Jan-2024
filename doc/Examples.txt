/*----------------------------------------------------------------------------------------------------------------------
	Java ile Nesne Yönelimli Programlama

	Eğitmen: Oğuz KARAN

	C ve Sistem Programcıları Derneği
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	23 Ocak 2024
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Java Platformunun Temel Özellikleri:
		- Arakodlu Çalışma Sistemi: C ve C++ gibi dillerde yazılan kodlardan elde edilen (nasıl elde edildiği bu aşamada
		önemli değildir) "çalışabilir dosya (executable file)" sisteme (genel olarak işletim sistemi, donanım vb.) 
		özgüdür ve koda göre her sistem için ayrıca oluşturulmalıdır. Hatta sisteme özgü kodlar yazılmışsa diğer sistemler
		için bu dosya oluşturulamaz. Oysa Java programlama dili ile yazılan bir program "derlendiğinde (compilation)" 
		oluşan dosyanın içerisinde hiç bir sistemin dili olmayan yapay bir arakod bulunur. Bu arakoda "byte code (BC)" denir.
		BC doğrudan çalıştırılamaz. Çalıştırılması için ayrı bir uygulama (program)  gerekir. Bu program, BC'yi
		yorumlayarak makine koduna yani sisteme özgü koda dönüştürerek programı çalıştırır. Bu dönüştürme işlemine
		JIT (Just In Time) compilation denir. Geliştirme ve çalıştırma anlamında 3 tane temel kavram karşımıza çıkar:
			- JVM (Java Virtual Machine): BC'yi makine koduna dönüştürür. JVM aslında BC'nin nasıl makine koduna
			dönüştürüleceğini tanımlayan soyut bir kavramdır.

			- JRE (Java Runtime Environment): Genel olarak Java ile yazılmış bir uygulamayı çalıştırmak (run)
 			için gereken araçları ve uygulamaları içeren bir pakettir. Yani BC elde edildiğinde bu programın 
			çalıştırılabilmesi için JRE'ye ihtiyaç vardır.

			- JDK (Java Development Kit): Geliştirme (development) araçlarını ve çalıştırma araçlarının bir çoğunu 
			içeren pakettir. Buradaki çalıştırma araçları geliştirme aşamasında kullanılabilir.

		Ticari kullanımlarda özellikle Java 11 ile birlikte bazı değişiklikler yapılmıştır. Genel olarak şöyle söylenebilir:
		Java'da geliştirme ortamı ücetsiz, çalıştırma araçları kullanılan araca göre ücretlendirilebilir.  Tamamen ücretsiz
		olarak kullanılabilen "Open JRE" gibi çalıştırma araçları da mevcuttur.  Burada anlatılanlar geneldir. Ayrıca, belirli
		bir noktadan sonra Java sürümleri için Long Term Support (LTS) kavramı da getirilmiştir. LTS sürümleri uzun süre 
		desteklenen yani güncellemesi (hızlandırılması, hataların düzeltilmesi vb.) uzun süre yapılan sürümlerdir. Java'da 
		Java 8, 11, 17 ve 21 sürümleri LTS sürümleridir. Bu kavramlar zamanla anlaşılacaktır.

		Arakodlu çalışma sisteminin en önemli avantajı, gelişirilen uygulamaların genel olarak sistemden bağımsız olarak 
		çalıştırılabilmesidir. Dolayısıyla kodun çalıştırılacağı sistemden bağımsız olarak ürün geliştirilebilir. Bu kavrama
		"Write Once Run Anywhere (WORA)" denilmektedir. Şüphesiz bu durumun da istisnaları vardır.

		Ayrıca unutulmamalıdır ki, arakodlu çalışma sistemi ufak da olsa bir performas kaybına yol açar. Ancak Java'nın hedeflediği
		uygulamalar düşünüldüğünde bu kaybın pek de önemi yoktur. Bu kaybın önemli olduğu uygulamalar için zaten Java ile 
		geliştirme yapılmaz. 

	Hızlı Uygulama Geliştirme Ortamı: Java hızlı uygulama geliştirme (rapid application development) ortamı sunar. Bu anlamda
	hem öğrenmesi kolaydır hem de ürün daha çabuk elde edilir. 

	Geniş bir sınıf kütüphanesi: Java'da oldukça geniş bir sınıf kütüphanesi bulunur. Veritabanı işlemleri, web programlama,
	dosya işlemleri gibi işlemler için hazır sınıflar bulunmaktadır.

	Güvenli Çalışma Ortamı: Java'da yazılmış olan bir programın sisteme zarar verme olasılığı çok daha azdır. Yazılan bir 
	program yüzünden yanlışlıkla makinede bir problem olma olasılığı oldukça düşüktür.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	25 Ocak 2024
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Programlama Dillerinin Sınıflandırılması: Programlama dilleri çeşitli şekillerde sınıflandırılabilse de genel olarak
	3 şekilde sınıflandırma eğilimi söz konusudur:
	1. Seviyelerine (level) göre sınıflandırma: Programlama dilinin seviyesi onun insan algısına yakınlığının ölçüsüdür. Yüksek
	seviyeli diller (high level languages) hem dil özellikleri, hem de uygulama geliştirme anlamında insan algısına yakınlıkları
	dolayısıyla daha kolay öğrenebilirler. Düşük seviyeli diller (low level languages) makineye daha yakın dillerdir. Olabilecek
	en düşük seviyeli dil makine dilidir.

	2. Kullanım alanlarına göre sınıflandırma: Dilin hangi alanlarda kullanılabileceğine göre sınıflandırmadır. Bazı diller
	birden fazla alanda kullanılabilirler. Bazı diller ise sadece bir alanda kullanılabilirler. Bu anlamda genel amaçlı diller,
	bilimsel ve mühendislik dilleri, veritabanı dilleri, yapay zeka dilleri, oyun ve animasyon dilleri vb. alanlar için diller
	söz konusu olabilmektedir.

	3. Programlama modeline göre sınıflandırma: Bir programı yazarken kullanılan genel model (paradigm) önemlidir. Bazı dillerde
	sınıf yoktur. Program çeşitli alt programların (function) bir araya getirilmesiyle yazılır. Bu modele "procedurel model"
	denir. Bazı dillerde sınıflar vardır ve programlar sınıflar kullanılarak yazılır. Başka bir çok kavramla birlikte sınıflar
	kullanılarak yazılan programlama modeline "nesne yönelimli model (object oriented model)" denir. Bazı dillerde programlar
	matematiksel formül yazıyormuş gibi yazılmaktadır. Bu tarz programlama modeline "fonksiyonel (functional)" model denir.
	Bazı diller birden fazla modeli desteklerler. Bu tarz dillere "multi paradigm languages" denilmektedir. Birden fazla modeli
	destekleyen diller, modellerin tüm özelliklerini desteklemeyebilir. 

	Bu durumda Java, bilimsel ve mühendislik uygulamalarında, web uygulamalarında, yapay zeka uygulamalarında, mobil
	programlamada vb. kullanılabilen genel amaçlı, yüksek seviyeli, nesne yönelimli programlama modeli ile uygulama
	geliştirilebilen ve özellikle Java 8 ile birlike fonksiyonel programlama modelini de belirli ölçüde destekleyen
	"multi paradigm" bir dildir.

	Anahtar Notlar: Bir dilin bir çok alanda kullanılabilmesi, o dilin tüm alanlarında pratikte kullanılacağı anlamına gelmez.
	Bir alanda daha etkin kullanılabilen bir dil varsa o dil daha fazla tercih edilebilir.

	Anahtar Notlar: Yukarıda anlatılan kavramların detayları vardır. Zaman içerisinde anlaşılacaktır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	30 Ocak 2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Temel Kavramlar:
	Çevirici Programlar, Derleyiciler ve Yorumlayıcılar: Bir dilde yazılmış programı başka bir dile çeviren programlara
	çevirici programlar (translator) denir. Çevirici programlarda bir kaynak dil (source language) ve bir hedef dil (target/destination language)
	vardır. Kaynak dil yüksek seviyeli, hedef dil düşük seviyeli bir programlama diliyse bu durumda çevirici programa
	derleyici (compiler) denir. Örneğin Java programlama dilinden Kotlin programlama diline dönüştürme yapan program
	bir translator, Java programlama dilinden byte code'a dönüştürme yapan program ise bir compiler'dır. JVM'in byte code'u
	makine koduna çevirme faaliyeti de bir derleme işlemidir. Bu sebeple buna JIT compilation denir. Bazı dillerde yazılan
	programlar herhangi bir kod üretilmeden çalıştırılırlar. Bu tarz dillerde yazılmış programları herhangi bir kod üretmeden
	çalıştıran programlara "interpreter" denir. Bazı diller hem derleyici hem yorumlayıcı ile kullanılabilirler. Java pratikte
	derleyici ile kullanılan, Java 11 ile birlikte "java" programı yorumlayıcı olarak da java kodunu byte code üretilmeden 
	çalıştırabilmektedir. Yorumlayıcı ile kullanılan diller derleyici ile kullanılan dillere göre daha yavaş olma eğilimindedir.

	Anahtar Notlar: Bir uygulama tek bir java dosyasından oluşmak zorunda değildir. Hatta bir Java uygulaması yalnızca
	java kodlarından da oluşmak zorunda değildir. Bu durumda farklı java dosyaları ayrı derlenir. Hatta aynı dosyada
	bulunan sınıflar da ayrı derlenir. Bir ürün aslında tüm birimlerinin uygun şekilde derlenmesi ve ele alınmasıyla
	elde edilir. Bu işleme genel olarak "build" terimi kullanılır. Build işlemi yalnızca derleme işlemi değildir. Yani
	bir uygulamanın ürün olarak elde edilmesi süreci "build" işlemidir. Burada anlatılanların da detayları zamanla
	ele alınacaktır.

	İşletim Sistemi (Operating System): Makinenin donanımını yöneten, bilgisayar ile kullanıcı arasında bir köprü oluşturan
	yazılımdır. Bir işletim sisteminin pek çok görevi vardır. Programları çalıştırmak, çeşitli cihazları ve aygıtları yönetmek,
	dosyaları ve dizinleri (directory) organize etmek vb. görevler sayılabilir. İşletim sistemleri genel olarak iki gruba
	ayrılabilir: masaüstü işletim sistemleri (desktop operating systems), mobil işletim sistemleri (mobile operating systems).
	Şüphesiz başka çeşit işletim sistemleri de vardır. Popüler masaüstü işletim sistemleri Windows, Mac OS X, Unix ve Linux
	dağitımları gibi işletim sistemleridir. Popüler mobil işletim sistemleri Android ve IOS'dur.

	Açık kaynak kodlu yazılım, özgür yazılım ve mülkiyete sahip yazılım: Özgür yazılım (free software) ve açık kaynak kodlu
	(open source) yazılımlar arasında farklar olsa da genel olarak aşağıdaki ortak özelliklere sahiptirler:
		- Bedavadır. Kullanılabilmesi için herhangi bir lisans gerekmez.
		- Kaynak kodlar sahiplenilemez. Kaynak koda ekleme yapıldığında ya da bir kaynak kod kullanıldığında kodlar kapatılamaz.
		Onların da açılması gerekir.
		- Çoğaltılabilir, izin almadan kullanılabilir.

	Bunun tam tersi olarak mülkiyete sahip (propriatery) yazlımlardır. Bu yazılımlar para verilerek kullanılır ve izin
	almadan çoğaltılamaz.

	IDE (Integrated Development Environment): Derleyicler ve yorumlayıcılar komut satırından çalışan ve basit arayüzlere
	sahip programlardır. Aslında teorik olarak bir uygulamadaki tüm Java dosyaları ve diğer dosyalar basit bir editör programla
	yazılıp komut satırından derlenebilir. Ancak bu, uygulama büyüdükçe zahmetli olmaya başlar. Bu da programcıya zaman
	kaybettirir. Bu amaçla pratikte yazılım geliştirmeyi kolaylaştırmak için IDE denilen yazılımlar kullanılır. IDE'lerde
	örneğin bir takım yardımlar veren editörler, tasarım araçları, test araçları, debug araçları vb. programcının geliştirme
	sırasında kullandığı araçlar bulunur. Java ile uygulama geliştirmede iki tane IDE yoğun olarak kullanılmaktadır:
	Eclipse, IntelliJIDEA. Biz kursumuzda belirli bir zaman (yaklaşık kursun yarısına kadar) Eclipse, sonrasında IntelliJIDEA
	kullanacağız.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	JDK'nın kurulumu için işletim sistemine göre aşağıdaki şu link'den ilgili "installer" indirilebilir: 
	https://www.oracle.com/tr/java/technologies/downloads/. Burada LTS olması açısından 17 veya 21 seçilebilir. 
	Kursumuzda Java 17 özellikleri de konular içerisinde ele alınacağından en az Java 17 kurulumu önerilir. Java 17 
	öncesinde en az Java 11 olmalıdır. Kurulum aşamasından sonra java ve javac programları -version seçeneği ile
	çalıştırılarak versiyon kontrolü yapılabilir. 
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki programı çalıştırmak için JDK kurulu olan bir bilgisayarda aşağıdaki işlemlerin yapılması gerekir:
	1. Herhangi bir dizinde (directory) csd isimli bir dizin açılır. Buradaki csd isminin tamamı küçük-harf olacak
	şekilde yazılacaktır.

	2. csd dizini içerisinde App.java isimli bir dosya açılır. Windows sisteminde uzantılar gizlenmişse görünür hale
	getirip uzantının .java olarak değiştirilmesi gerekir. Buradaki dosya isminin aynen yazılması gerekir.

	3. Komut yorumlayıcı program (command promt/terminal/shell) ile csd directory'sinin bulunduğu dizine geçilir. Dizin
	geçişi için cd komutu kullanılır. Örneğin cd cd D:\Repositories\Java-Jan-2024\src\src-console

	4. Herhangi bir editör program ile App.java dosyasının içerisine aşağıdaki programı yazınız.

	5. Komut yorumlayıcı programda, csd'nin bulunduğu dizinde aşağıdaki komutları çalıştırarak derleme işlemi yapılır:
		javac csd/App.java -> Windows dışı sistemler için
		javac csd\App.java -> Windows sistemi için
	Derleme işleminde herhangi bir hata (error) mesajı alınmazsa derleme işlemi başarılıdır ve App.class isminde byte code
	üretilir

	6. Komut yorumlayıcı programda aşağıdaki biçimde byte code çalıştırılır:
		java csd.App

	Anahtar Notlar: Yukarıdaki maddelerdeki bazı zorunluluklar ilerideki konularda anlaşılacaktır.	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello, World");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	1 Şubat 2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Dil Kavramı: İletişimde kullanılan sembollere dil denir. Dilin kurallarına gramer denir. Bir olgu en az şu iki özelliğe
	sahipse bir dildir:
	1. Sentaks (syntax): Dilin öğrelerinin doğru dizilimine denir. Örneğin "I am a student" cümlesinde dilin öğeleri doğru 
	dizilmiştir. Cümle "am a student I"  biçiminde yasılsaydı sentaks olarak hatalı olurdu.
	2. Semantik (semantic): Doğru dizilmiş öğelerin anlamına denir. Öğeler doğru dizilse bile cümle anlamlı değilse yine
	hatalıdır. 

	Doğal dillerde sentaks ve semantik dışında da kavramlar bulunur. Bilgisayar bilimlerinde kullanılan dillere 
	bilgisayar dilleri (computer languages) denir. Bir bilgisayar dili akış (flow) içeriyorsa programlama dili (programming language)
	denir. Her bilgisayar dili bir programlama dili değildir. Örneğin html, XML gibi bilgisayar dilleri akış içermediği
	için programlama dili değildir. Java bir programlama dilidir.

	Programlama dilleri zaman içerisinde birbirilerinden esinlenmiştir. Hatta bazı programlama kalıpları da bir takım
	dillerden alınarak kullanılmaktadır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Derleyicinin verdiği mesajlar: Derleyiciler koda ilişkin bazı teşhiş mesajları (diagnostics) verebilirler. 
	Derleyicilerin teşhis mesajları iki gruba ayrılır:
	1. Gerçek hatalar (errors): Sentaks veya semantik olarak geçersiz bir durumda derleyicinin verdiği mesajlardır. Bu
	durumda BC üretilmez. Programcının hataya yol açan durumları düzeltmesi ve derleme işlemini yapması gerekir.

	2. Uyarılar (warnings): Programcının olası programlama hatalarına yönelik mesajlardır. Uyarı mesajları ara kodun
	üretimini engellemez. Ancak programcı tarafından dikkate alınmalıdır. Özel bir durum yoksa uyarı mesajlarına yol
	açan durumların ortadan kaldırılması gerekir. Bazı durumlarda programcının kullandığı bazı static kod analizi
	araçları da derleyici dışında bazı uyarılar verebilirler. Şüphesiz bunlar da dikkate alınmalıdır ancak hepsinin
	ortadan kaldırılması gerekmeyebilir. Pratikte bir ürünün nihayi (release) versiyonunda derleyicinin tüm uyarı
	mesajlarının kaldıırlmış olması gerekir.

	3. Ölümcül hatalar (fatal errors): Derleme işleminin dahi tamamlanamadığı hatalardır. Örneğin derlenecek dosyanın 
	bulunamamaı, diskte yer kalmaması, sistemsel problemler oluşması vb. Bu durumda programcının ölümcül hataya yol
	açan durumu ortadan kaldırıp derleme işlemini yapması gerekir. Yani ölümcül hata durumunda programcının kodu
	ile bir durum yoktur.

	Derleme işleminin başarıyla yapılması durumunda derleyiciler ya hiç bir mesaj vermezler ya da derleme işleminin
	başarılı olduğu da anlaşılan mesajlar verirler. 

	Programın çalışma zamanında oluşan hatalı durumlara genel olarak "excaption" veya "run time error" denir. Exception
	handling konusuna gelene kadar bir exception oluştuğunda program abnormal bir biçimde sonlanır olarak düşüneceğiz.

	Anahtar Notlar: Bir program için, programcı açısından iki durum söz konusudur: 
	1. Derleme zamanı (compile time): Derleme işlemine ilişkin süreçtir.
	2. Çalışma zamanı (run time): Programın çalıştırlması sürecidir. 

	Şüphesiz derleme zamanı ve çalışma birbirleri ile ilişkildir. Sonuçta bir program derlenmeden zaten çalıştırılamaz.
	Her ne kadar ilişkili de olsalar birbirlerinden farklı kavramlardır.
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
	Atom (Token): Programlama dilinin bölünemeyen en küçük birimine denir. Java programlama dilinde atomlar şunlardır:
	1. Anahtar Sözcükler (keywords/reserved words): Derleyicinin bildiği, tanıdığı sözcüklerdir. Anahtar sözcükler 
	tek başına değişken ismi olamazlar. Örneğin:
		package, int, class

	2. Değişken atomlar (variables/identifiers: İsmini programcının belirlediği ve isimlendirmeye ilişkin kuralları
	olan atomnlardır. Örneğin:
		csd, App, String 

	3. Sabitler (literals/constants): Program içerisine doğrudan yazılan değerlere denir. Örneğin:
		10, 20

	4. Operatörler (operators): Belirli işleme yol açan ve işlem sonunda bir değer üreten atomlardır. Örneğin:
		a + b ifadesinde + bir operatördür
		++a ifadesinde ++ bir operatördür

	5. String'ler (strings/string literals): İki tane iki tırnak (double quote) içerisinde yazılan yazılara tırnaklarıyla
	birlikte string ya da string literal denir. Örneğin:
		"Hello, World"

	6. Ayraçlar (delimiters/punctuators): Yukarıdakiler dışında kalan atomlardır. Örneğin
		{}, ()

	Derleme işlemi atomlarına ayırmakla (tokenizing) başlar.

	Anahtar Notlar: Klavyeden basıldığında boşluk hissi veren karakterlere boşluk karakterleri (whitespaces) denir. 
	Klavyden basılaon tipik boşluk karakterleri şunlardır: SPACE, TAB, ENTER
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java'da kod yazım kuralları genel olarak şu şekilde özetlenebillir:
	1. Atomlar arasında istenildiği kadar boşluk bırakılabilir
	2. Değişken atomlar ve anahtar sözcükler kendi aralarında bitişik yazılması dışındaki tüm atomlar bitişik yazılabilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Atomlar arasında istenildiği kadar boşluk bırakılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App 










{
	public static void main(
		
	
	
	
	String [] args)
	{
		System.out
		
		
		
		
		
		.														println("Hello World");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Atomlar bitişik yazılabilir
----------------------------------------------------------------------------------------------------------------------*/

package csd;class App{public static void main(String[]args){System.out.println("Hello, World");}}

/*----------------------------------------------------------------------------------------------------------------------
	Değişken atomlar ve anahtar sözcükler bitişik yazılamazlar
----------------------------------------------------------------------------------------------------------------------*/
packagecsd;class App{public static void main(String[]args){System.out.println("Hello, World");}} //error

/*----------------------------------------------------------------------------------------------------------------------
	Programlamada derleyicinin gözrmezden geldiği kod parçalarına yorum satırları (comment lines) denir. Java'da iki
	çeşit yorum satırı yazılabilir. Yorum satırlarının okunabilirliği/algılanabilirliği olumsuz etkilememesi gerekir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) //Burası görmezden gelinecek
	{
		/*
		 	Burası da derleyici tarafından
			görmezden gelinecektir
		 */
		System.out.println("Hello, World");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	6 Şubat 2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bildirim (Declaration): Bir ismin derleyiciye tanıtılmasıdır.
	Bir dilin kurallarının genel biçimlerini açıklamaya yönelik pek çok notasyon kullanılmaktadır. Biz burada "açısal 
	parantez-köşeli parantez" tekniğini kullanacağız. Bu teknikte zorunlu olması gerekenler açıklamada açısal parantez
	içerisine alınır. Seçenekli olması gerekenler ise köşeli parantez içerisine alınır. Herhangi bir paranteze alınmayanlar
	aynı şekilde bulundurulması gerekenlerdir. Ayrıca 
		//...
	"burada bir takım kodlar var ancak şu an bizi ilgilendirmiyor" anlamına gelecektir. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	"Hello World" Programının Genel Açıklaması:
	Bir Java programı genel olarak paketlerden (package), paketler sınıflardan (class), sınıflar da metotlardan (method)
	oluşur. Paket bildiriminin genel biçimi:
	
		package <isim>;
		
	Burada isim daha sonra ele alacağımız değişken isimlendirme kurallarına uygun bir isim olmalıdır. Paketler konusu
	çok detaylı bir konudur, ileride detaylı olarak ele alınacaktır. Biz ilgili konuya kadar yalnızca csd paketi içerisinde
	kodlama yapacağız. 
	
	Sınıf bildiriminin genel biçimi şu şekildedir:
	
	[bildirime ilişkin bazı anahtar sözcükler] class <isim> {
		//...
	}
	
	Burada isim değişken isimlendirme kurallarına uygun olmalıdır. Sınıf kavramı da oldukça geniş bir kavramdır. Sınıf bildiriminin
	detayları konular içerisinde ele alınacaktır. Sınıf kavramı Nesne Yönelimli Programlama Tekiniğinin de temel taşlarından
	biridir.  
	
	Java'da alt programlara metot denir. Metot bildirimi (method declaration) alt programın kodlarının yazılmasıdır. Bir 
	metot bildirildiğinde kodlarının çalıştırılabilmesi için çağrılması (call/invoke) gerekir. Metot bildiriminin genel
	biçimi şu şekildedir:
	
	[erişim belirleyici] [static] <geri dönüş değeri bilgisi> <isim>([parametre listesi])
	{
		//...
	}
	
	Erişim belirleyici şunlar olabilir: public, no-modifier (hiç bir şey yazmamak), protected, private. İlgili konuya
	gelene kadar tüm metotlarımızı public olarak bildireceğiz. Bir metot static veya non-static olabilir. static anahtar
	sözcüğü yazılmadığında metot non-static olur. İlgili konuya gelene kadar tüm metotlarımızı static olarak bildireceğiz.
	Bir metodun geri dönüş değeri (return value) olabilir ya da olmayabilir. Bir metodun geri dönüş değeri yoksa void
	anahtar sözcüğü yazılır. Metot ismi değişken isimlendirme kurallarına uygun bir isim olmalıdır. Bir metodun parametreleri
	olabilir ya da hiç olmayabilir. Metot bildiriminde { ile } arasında kalan kod bölümüne metodun gövdesi (body) denir.
	Metodun ne iş yaptığı yani kodları buraya yazılır. Parametre kavramı ileride ele alınacaktır. static bir metodu 
	çağırmanın genel biçimi şu şekildedir:
	
		[paket ismi].[sınıf ismi].<metot ismi>([argümanlar]);
		
	Argüman kavramı ileride ele alınacaktır. Bir metot çağrıldığında akış metodun kodlarına dallanır. Çağrılan metodun
	kodları çalıştırılır. Metot çağrısı bittiğinde akış çağıran metoda (çağrılan noktaya) geri döner. Akış main metodundan
	başlar. Akışın başladığı main metoduna "entry point" denir. Özel bazı durumlar dışında main metodu bittiğinde program
	sonlanır. print ve println metotları aldıkları değerleri ekrana basmak için kullanılan standart metotlardır. Bu metotlar
	non-static metotlardır. Dolayısıyla çağrıdaki System bir paket değildir. println ekrana ilgili yazıyı bastıktan sonra
	imleci (cursor) bir sonraki satırın başına çeker. Yani bir sonraki yazma işlemi, bir sonraki satırın başından itibaren
	yapılır. print metodu ise imleci en son yazdığı karakterden sonrasına çeker. Bu durumda bir sonraki yazma işlemi
	buradan yapılır 
	
	Anahtar Notlar: Aslında teknik olarak print ve println gibi metotlar ekrana yazma yapmazlar. Bu metotlar ismine
	standard output (stdout) denilen kabaca bir dosyaya yazma yaparlar. stdout dosyası ekrana yönlendirildiğinde
	biz çıktıları ekranda görürüz. Kursumuzda basitleştirmek için ekran terimini kullanacağız. Benzer şekilde 
	klavyeden okuma yapan metotlar, okumayı aslında standard input (stdin) denilen bir dosyadan yaparlar. Dosya, klavyeye
	yönlendirildiğinde okuma klavyeden yapılmış olur. Kursumuzda basitleştirmek için klavye terimini de kullanacağız. Masaüstü
	işletim sistemlerinin hemen hepsinde stdout ekrana, stdin ise klavyaye yönlendirilmiştir. Ayrıca IDE'ler de stout'u 
	genel olarak kendi console pencerelerine yönlendirirler. 
	
	Anahtar Notlar: Java'nın standart (yani hazır olarak) sınıflarının ve metotlarının buluduğu kütüğhaneye genele olarak
	JavaSE (Java Standard Edition) denilmektedir.	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello, World");
		csd.Sample.foo();
		csd.Mample.bar();
		System.out.println("Goodbye, World");
	}
}


class Sample {
	//...
	public static void foo()
	{
		System.out.println("foo");
	}
}

class Mample {
	//...
	public static void bar()
	{
		System.out.println("bar");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Çağıran metodun (caller) ait olduğu sınıf ile çağrılan metodun (callee) ait olduğu sınıf aynı paket içerisindeyse 
	çağrı sırasında paket ismi kullanılmasına gerek yoktur. Çağıran metot ile çağrılan metot aynı sınıf içerisindeyse
	ve paket ismi çağrıda kullanılmamışsa sınıf ismi de yazmaya gerek yoktur. Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello, World");
		Sample.foo();
		Mample.bar();
		System.out.println("Goodbye, World");
	}
}


class Sample {
	//...
	public static void foo()
	{
		tar();
		System.out.println("foo");
		Mample.bar();
	}
	
	public static void tar()
	{
		System.out.println("tar");
	}
}

class Mample {
	//...
	public static void bar()
	{
		System.out.println("bar");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	8 Şubat 2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sayı Sistemleri
----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Sayı sistemleri
	Biz 10'luk sistemi (decimal system) kullanmaktayız. 10'luk sistemde sayıları ifade etmek için 10 sembol vardır:

	0
	1
	2
	3
	4
	5
	6
	7
	8
	9

	10'luk sistemde sayının her bir basamağı 10'nun kuvvetleriyle çarpılıp toplanmaktadır. Örneğin:

	123.25 = 3 * 10^0 + 2 * 10^1 + 1 * 10^2 + 2 * 10^-1 + 5 * 10^-2

	Halbuki bilgisayarlar 'lik sistemi (binary system) kullanmaktadır. 2'lik sistemde sayıları ifade etmek için 2 sembol kullanılmaktadır:

	0 
	1

	2'lik sistemde sayının her bir basamağına "bit (binary digit)" denilmektedir. 2'lik sistemde sayının her basamağı 2'nin kuvvetiyle çarpılarak sayı elde edilir.
	Bit en küçük bellek birimidir. 8 bite 1 byte denilmektedir. Genellikle bitler 4'erli gruplanarak yazılırlar. Örneğin:

	1010 0010

	Burada 1 byte'lık bir bilgi vardır. Byte temel bellek birimidir. 

	Byte da küçük bir birimdir. Kile diğer bilimlerde "1000 katı" anlamına gelmektedir. Ancak bilgisayarlar 2'lik sistemi kullandığj için 1000 katı iyi bir
	kat değildir. Bu nedenle genel olarak Kilo byte için 2'nin 102uncu kuvveti olan 1024 kat kullanılır. Yani 1KB (kısaca 1K) 1024 byte'tır. Mega diğer bilimlerde 
	kilonun 1000 katıdır. Dolayısıyla milyan kat anlamına gelmektedir. Ancak bilgisayar bilimlerinde genel olarak mega kilonun 1024 katı olarak alınır. 
	Bu durumda 1 MB = 1020 * 1024 (2^20) KB'dir. Giga ise meganın 1024 katıdır. Bu durumda 1 GB = 1024 * 1024 * 1024 byte'tır ( 2^30). Giga'dan sonra tera, tera'dan sonra 
	peta, ondan sonra da exa gelmektedir. 

	1 byte içerisinde yazılabilecek en küçük ve en büyük sayılar şöyledir:

	0000 0000 ---> 0
	1111 1111 ---> 255

	1 byte içerisinde 1 ve 0'ların bütün permütasyonları 256 tanedir. 2 byte içerisinde en büyük sayıyı yazacak olsak şöyle olurdu:

	1111 1111 1111 1111 ---> 65535

	Biz burada ikilik sistemde tamsayıları ifade ettik. Ama bütün sayıları pozitif kabul ettik. Pekiyi negatif tamsayılar nasıl ifade edilmektedir?

	Bugün negatif sayıların ifade edilmesi için "ikiye tümleyeb (two's complement)" sistemi denilen bir sistem kullanılmaktadır. Bu sistemde pozitif ve 
	negatif sayılar birbirlerinin ikiye tümleyenidirler. ikiye tümleyen bire tümleyene bir eklenerek bulunmaktadır. Bir sayının bire tümleyeni sayıdaki
	o'ların 1, 1'lerin 0 yapılmasıyla bulunur. Bu durumda ikiye tümleyen şöyle hesaplanır. örneğin aşağıdaki sayının ikiye tümleyenini bulmaya çalışalım:

	0101 0110

	Sayının bire tümleyenine bir ekleyeceğiz:

	1010 1001
    0000 0001
    ---------
    1010 1010

	Aslında ikiye tümleyeni bulmanın kolay bir yolu da vardır: Sayıda sağdan sola ilk 1 görene ilk 1 dahil olmak üzere aynısı yazılarak ilerlenir. 
	Sonra 0'lar 1, 1'ler 0 yapılarak devam edilir. Örneğin:

	0101 0110

	sayının ikiye tümleyenini tek hamlede bulalım:

	10101010

	Negatif sayıları ifade edebilmek için kullanılan ikiye tümleme sisteminde en soldaki bit işaret bitidir. Bu bit 0 ise sayı pozitif, 1 ise negatiftir.
	Negatif ve pozitif sayılar birbirlerinin ikiye tümleyenidir. Örneğin bu sistemde +10 yazmak isteyelim. Bunu işaret 0 yaparak yazabiliriz:

	0 000 1010		---> +10

	Şimdi -10 yazmak isteyelim. Bunun için +10'un ikiye tümleyenini alalım:

	1 111 0110       ---> -10

	Bu sistemde +n ile -n toplandığında 0 elde edilir:

	0 000 1010   ---> +10
	1 111 0110   ---> -10
	---------------------
  1	0 000 0000   ---> 0

  	Bu sistemde tek bir sıfır vardır. O da tüm bitleri 0 olan sıfırdır. Bu sistemde 1 byte içerisinde yazılabilecek en büyük pozitif sayı şöyledir:

	0 111 1111    ---> +127

	Şimdi bunun ikiye tümleyenini alalım:

	1 000 0001    ---> -127

	Pekiyi en küçük negatif sayı nedir? Bu sistemde bir tane sıfır olduğuna göre 255 tane permütasyon eşit bölünemez. Demek ki ya pozitif sayılar ya negatif sayılar 
	bir tane daha fazla olmak zorundadır. Bu sistemde ikiye tümleyeni olmayan iki sayı vardır:

	0000 0000 
	1000 0000

	Birincisi 0'dır. İkinci sayı -127'den bir eksik olan sayıdır. O halde bu sayının -128 kabul edilmesi daha uygundur. 

	Demek ki bu sistemde n byte içerisinde yazılabilecek en büyük pozitif sayı ilk biti 0 olan diğer tüm birleri 1 olan sayıdır. En küçük 
	negatif sayı ise ilk biti 1 olan diğer tüm bitleri 0 olan sayıdır. Örneğin bu sistemde iki byte ile yazabileceğimiz en büyük pozitif sayı
	şöyledir:

	0111 1111 1111 1111		---> +32767

	En küçük negatif sayı ise şöyledir:

	1000 0000 0000 000   	---> -32768

	Bu sisteme ilişkin tipik sorular ve yanıtları şöyledir:

	SORU: Bu sistemde +n sayısını nasıl yazarsınız?
	CEVAP: En soldaki bit 0 yapılıp n sayısı 2'lik sistemde yazılır.

	SORU: Bu sistemde -n nasıl yazarsınız?
	CEVAP: Yazabiliyorsanız doğrudan yazın. Ancak doğrudan yazamıyorsanız önce +n değerini yazın ve ikiye tümleyenini alın. Örneğin bu sistemde -1 
	yazalım. Önce +1 yazalım:

	0000 0001   ---> +1

	Şimdi bunun ikiye tümleyenini alalım:

	1111 1111   ----> -1

	SORU: Bu sistemde bir sayının kaç olduğu bize sorulsa bunu nasıl yanıtlarız?
	CEVAP: Eğer en soldaki bit 0 ise sayının değeri doğrudan hesplanır. Eğer en soldaki bit 1 ise bu sayının negatif olduğunu gösterir. Bu durumda 
	sayının ikiye tümleyeni alınır. Pozitifinden hareketle negatifi bulunur. Örneğin 1110 1110 sayısı kaçtır? Burada işaret biti 1 olduğuna göre sayı negatiftir. 
	Negatif ve pozitif sayılar birbirlerinin ikiye tümleyenidirler. O zaman bu sayının ikiye tümleyenini alıp pozitifinden faydalanarak sayıyı bulalım:

	0001 0010  ---> +18

	o zaman bize sorulan sayı -18'dir.

	Bu sistemde örneğin 1 byte içerisinde yazılabilecek en büyük pozitif sayıya 1 toplayalım:

	0111 1111   ---> +127
	1000 0000   ---> -128

	Demek ki bu sistemde bir sayıyı üst limitten taşırırsak yüksek bir negatif sayıyla karşılaırız. Benzer şekilde alt limitten taşırırsak yüksek bir 
	pozitif sayı ile karşılaşırız	 
----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Tamsayılar ikilik sistemde "işaretsiz (unsigned)" ya da "işaretli (signed)" sistemde yorumlanabilirler. İşaretsiz sistemde sayının en soldaki biti
	olarak yorumlanmaz. Sayı herzaman sıfır ya da pozitiftir. İşaretli sistemde ise sayının en solundaki bit işaret bitidir. Sayı ikiye tümleyen aritmetiğine 
	göre yorumlanır.
	 
	İşlemciler aslında genellikle işaretli ve işaretsiz ayırımını yapmazlar. Çünkü bu tür de aslında aynı biçimde işleme sokulmaktadır. Sonucun yorumu değişmektedir. 
----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi noktalı sayılar ikilik sistemde nasıl ifade edilmektedir? İşte insanlar noktalı sayıları ifade etmek için iki format geliştirmişlerdir. Bunlardan birine
	"sabit noktalı formatlar (fixed point formats)" diğerine "kayan noktalı formatlar (floating point formats)" denilmektedir. Sabit noktalı formatlar eski 
	devirlerde basit bir mantıkla tasarlanmıştır. Bu formatlar bugün hala kullanılıyor olsa da büyük ölçüde artık bunların çağı kapanmıştır. Bugün kayan noktalı
	format denilen formatlar kullanılmaktadır. 

	Sabit noktalı formatlarda noktalı sayı için n byte yer ayrılır. Noktanın yeri önceden bellidir. Örneğin sayı 4 byte ile ifade edilsin. 
	Noktanın yeri de tam ortada olsun. Bu durumda syının tam kısmı 2 byte ile noktalı kısmı 2 byte ile ifade edilir. Ancak sayının noktalı kısmı 2'nin
	negatif kuvvetleriyle kodlanmaktadır. VBöylece iki sabit noktalı sayıyı paralel toplayıcılarla kolay bir biçimde toplayabiliriz: Örneğin bu sistemde 
	5.25 ile 6.25 sayılarını ifade edip toplayalım:

	0000 0000 0000 0101 . 0100 0000 0000 0000    ---> 5.25
	0000 0000 0000 0110 . 0100 0000 0000 0000    ---> 6.25
	-------------------------------------------------------
	0000 0000 0000 1011 . 1000 0000 0000 0000    ---> 11.5

	Pekiyi bu yöntemin ne dezavantajı vardır? Yöntemin en önemli dezavantajı dinamik olmamasıdır. 

----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Sabit noktalı formatların dinamik olmaması nedeniyle kayan noktalşı formatlar geliştirilmiştir. Bu formatlarda noktanın yeri sabit değildir. 
	Noktanın yeri format içerisinde ayrıca tutulmaktadır. Noktalı sayının noktası yokmuş gibi ifade edilmesi durumunda sayının bu haline "mantis (mantissa)" 
	denilmektedir. İşte kayan formatlarda sayı için ayrılan alanın bir bölümünde manris bir bölümünde de "noktanın yeri" tutulmaktadır. Noktanın yerini belirleyen
	kısma "üstel kısım (exponential part)" denilmektedir. Tabii bir de sayının başında işaret biti bulunur. Bu durumda kayan noktalı bir sayının format aşağıdakine benzerdir:

	[işaret biti] [mantis] [noktanın yeri (exponential)]

	Bugün ağırlıklı kullanılan kayan noktalı format IEEE 754 denilen formattır. Bu formatın üç farklı genişlikte biçimi vardır:

	IEEE 754 - Short Real Format (4 byte)
	IEEE 754 - Long Real Format (8 byte)
	IEEE 754 - Extended Real Format (10 byte)
	
	Bugün Intel, ARM, MIPS, Alpha, Power PC gibi yaygın işlemciler donanımsal olarak bu formatı desteklemektedir. Aynı zamanda bu format yaygın olarak Reel Sayı Ünitesi
	olmayan mikrodenetleyicilerdeki derleyiciler tarafından da kullanılmaktadır.

	Kayan noktalı formatların (örneğin IEEE 754 formatının) en ilginç ve problemli tarafı "yuvarlama hatası (rounding error)" denilen durumdur. Yuvarlama hatası
	noktalı sayının tam olarak ifade edilemeyip onun yerine ona yakın bir sayının ifade edilmesiyle oluşan hatadır. Yuvarlama hatası sayıyı ilk kez depolarken de 
	oluşabilir, aritmetik işlemlerin sonucunda da oluşabilir. Tabii noktalı sayıların bir bölümü bu formatta hiçbir yuvarlama hatasına maruz kalmadan ifade edilebilmektedir. 
	Ancak bazı sayılarda bu hata oluşabilmektedir. Bu hatayı ortadan kaldırmanın yolu yoktur. Tabii sayı için daha fazla bir ayrılırsa yuvarlama hatasının etkisi de 
	azalacaktır. 

	Yuvarlama hatalarından dolayı programlama dillerinde iki noktalı sayının tam eşitliğinin karşılaştırılması anlamlı değildir. Örneğin aşağıdaki işlemde
	yuvarlama hatasından dolayı sayılar sanki eşit değişmiş gibi ele alınacaktır.  

	0.2 + 0.1 == 0.3 (false)
	
	Pekiyi yuvarlama hatasının önemli olduüu ve bunun istenmediği tarzda uygulamalarda (örneğin finansal uygulamalarda, bilimsel birtakım uygulamalarda)
	ne yapak gerekir? İşte bunun tek yolu noktalı sayıları kayan noktalı formatta tutmamak olabilir. Bazı programlama dillerinde noktalı sayıyı 
	kayan noktalı formatta tutmayan böylece yuvarlama hatalarına maruz bırkmayan özel türler (örneğin C#'taki decimal) vardır. Ancak bu türler işlemciler tarafından 
	desteklenmediği için yapay türlerdir. 

----------------------------------------------------------------------------------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Bilgisayar dünyasında çok kullanılan diğer bir sayı sistemi de 16'lık sistemdir. 16'lık sisteme İngilizce "hexadecimal system" denilmektedir. 16'lık 
	sistemde syaıları ifade etmek için 16 sembol bulunmaktadır. İlk 10 sembol 10'luk sistemdeki sembollerden alınmıştır. Sonraki 6 sembol alfabetik karakterlerden alınmıştır:

	0
	1
	2
	3
	4
	5
	6
	7
	8
	9
	A
	B
	C
	D
	E
	F

	16'lık sistemdeki her bir basamağa "hex digit" denilmektedir. Örneğin:

	1FC8

	Burada 4 hex digit'lik bir sayı vardır. 16'lık sistemdeki bir sayıyı 10'luk sisteme dönüştürmek için her hex digit 16'lık kuvvetleriyle çarpılıp toplanır. 
	Ancak 16'lık sistemdeki sayı kullanım gereği bakımından aslında 10'lu sisteme pek dönüştürülmez. 16'lık sistemdeki her bir hex digit 4 bit ile ifade edilebilmektedir:

	0		0000
	1		0001
	2		0010
	3		0011
	4		0100
	5		0101
	6		0110
	7		0111
	8		1000
	9		1001
	A		1010
	B 		1011
	C 		1100
	D 		1101
	E 		1110
	F       1111

	16'lık sistemden 2'lik sisteme dönüştürme yapmak çok kolaydır. Tek yapılacak şey bir hex digit'e karşılık yandaki tablodaki 4 biti getirmektir. Örneğin:

	1FC9  =  0001 1111 1100 1001
	FA3D  =  1111 1010 0011 1101

	2'lik sistemdeki bir sayı da 16'lık sisteme çok kolay dönüştürülür. Tek yapılacak şey sayıyı dörderli gruplayıp ona karşı gelen hex digit'i yazmaktır. Örneğin:

	1010 0001 1110 1000 0011 0101 = A1E835

	Bilgisayar dünyasında 162lık sistem aslında 2'lik sistemin yoğun bir gösterimi olarak kullanılmaktadır. Yani 2'lik sistem çok yer kapladığı için kişiler
	2'lik sistem yerine 16'lık sistemi kullanırlar. Bu nedenle belleği, dosyayı gösteren programlar bunları 2'lik sistem yerine 16'lık sistemde gösterirler. 

	1 byte 2 hex digit ile ifade edilmektedir. Örneğin:

	1A 23 5C 78

	Burada 4 byte'lık bir bilgi vardır. Örneğin 2 byte içerisinde yazılabilecek en küçük negatif işaretli sayının hex karşılığı 8000 biçimindedir. Örneğin
	bir byte'lık işaretli sistemde yazılabilecek en büyük pozitif sayı 7F biçimindedir. İşareti tamsayı sisteminde 4 byte içerisinde -1 sayısı FFFFFFFF 
	biçimindedir. 

----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Eskiden daha fazla kullanılıyor olsa da toplamda oldukça seyrek kullanılan diğer bir sayı sistemi de 8'lik sayı sistemidir. Bu sisteme İngilizce 
	"octal system" denilmektedir. 8'lik sayı sistemindeki her bir basamağa "octal digit" denir. Octal digit sembolleri olarak 10'luk sistemin ilk 8 sembolü 
	kullanılmaktadır:

	0
	1
	2
	3
	4
	5
	6
	7

	Her octal digit 3 bir ile ifade edilebilir:

	0	000
	1	001
	2	010
	3	011
	4	100
	5	101
	6	110
	7	111

	Bu durumda bir octal sayı 2'lik sisteme kolay bir biçimde dönüştürülebilir:

	476		100 111 110
	741		111	100	001

	Benzer biçimde 2'lik sistemdeki bir sayı da sağdan sola üçer bir gruplandırılarak 8'lik sisteme dönüştürülebilmektedir. Örneğin:

	1011 1011	=  273
	0111 1110	=  176

	8'lik sistem de 2'lik sistemin yoğun bir gösterimi olarak kullanılmaktadır. Ancak 8'i tam ortalayamadığı için kullanımı seyrektir. 
----------------------------------------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
	Tür (Type): Bir değişkenin içerisindeki değerin ne kadar uzunlukta tutulduğunu yani bellekte ne kadar ayrılacağını
	ve değerin hangi formatta tutulacağını belirtir. Java'da temel türler (primitive/built-in/predefined) şunlardır:
	
	
	Tür						Uzunluğu (byte/bit)
	int							   4/32
	long						   8/64
	short						   2/16
	byte						   1/8
	
	double						   8/64
	float						   4/32
	
	char						   2/16
	boolean						   -
	
	Açıklamalar:
	- Java'da temel tür isimlerinin her biri birer anahtar sözcüktür.
	
	- int, long, short ve byte türlerine tamsayı türleri (integer/integral types) denir.
	 
	- Tamsayı türleri için işaretli sistemde 2'ye tümleme formatını kullanılar. Java'da işaretsiz tamsayı türü yoktur.
	
	- double ve float türlerine "gerçek sayı türleri (real types)" denir. Gerçek sayı türleri için IEEE 754 
	formatı kullanılır. Bu sebeple türlere "floating point types" da denilmektedir. Bu türlerle yapılan işlemlerde
	IEEE 754 satandardının çalışma sistemi gereği yuvarlama hataları (rounding error) oluşabilir. Bu yuvarlama hatalarının
	problem olabileceği uygulamalarda (örneğin  parasal ve finansal uygulamalarda) bu türler kullanılmazz. Bu tip durumlarda
	hangi türlerin kullanılacağı ileride ele alınacaktır.
	
	- Programlamada kullanılan karakterler bir tabloda tutulurlar. Bu tabloya karakter tablosu denilmektedir. Programlamada 
	pek çok karakter tablosu kullanılabilmektedir. Daha önceleri ASCII denilen ve 7 bit olarak tutulan ancak daha sonra 8 bit 
	olarak ele alınan bir karakter tablosu vardır. Daha sonraları dünyada kullanılan pek çok karakterin de tutulabilmesi 
	için UNICODE isimli bir karakter tablosu kullanılmaya başlanmıştır. UNICODE tablosunun ilk 128 karakteri ASCII ile 
	aynıdır. UNICODE tablosunun da çeşitleri vardır. char türü içerisinde tutulan sayı ilgili tabloda sıra numarası
	olarak yorumlanır. Yani char türü içerisinde tutulan sayı aslında ilgili karakter tablosunda bir karakterin
	sıra numarasına karşılık gelir. Bu anlamda char türü UNICODE tablosunun 2 byte'ı ile uyumludur. Karakter tablolarına
	ilişkin detaylar ileride ele alıncaktır.
	
	- boolean türü mantıksal olarak doğru ve yanlış kavramlarını temsil eden bir türdür. boolean türünden bir değişeken
	iki tane değer alabilir: true, false. Bu tür örneğin flag değişkenlerde kullanılabilir. boolean türünün uzunluğu
	Java Language Specifcation dökumanında belirtilmemiştir. Zaten iki tane değer aldığı için de uzunluğunun kaç olduğunun
	programcı açısından önemi yoktur.
	
	- Her ne kadar 8 tane tür olsa da programcı tamsayı kullanacağı zaman önce int türünü düşünür, int türünün senaryoya
	uygun olmadığı durumda (örneğin daha fazla değer tutulması gerekirse) diğer türler tercih edilmelidir. Benzer 
	şekilde gerçek sayılar için de öncelikle double türü düşünülmeli, duruma göre float türü tercih edilmelidir. Diğer 
	türler (char ve boolean) zaten özel amaçlı türlerdir. Bu anlamda int ve double türlerine "default types" da denilmektedir
	
	- Java'da boolean türü dışında kalan temel türlerin uzunlukları her sistemde aynıdır. boolean türünün aldığı iki
	tane değer olduğundan yani herhangi bir sınır söz konusu olmadığından programcı açısından uzunluğun da önemi
	yoktur.
	
	- int türüne "integer" demek yanlış bir tanım kullanmak demektir. integer kavramı tam sayılara verilen genel bir 
	isimdir. int ise 4 byte'lık bir tamsayı türüdür. Ayrıca JavaSE'de Integer isimli önemli bir sınıf da bulunmaktadır.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği çalıştırıp yuvarlama hatasını gözlemleyiniz. Kodun detayları şu an için önemsizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		double a = 0.1, b = 0.2;
		double c;
		
		c = a + b;
		
		System.out.printf("c = %.20f%n", c);
		
		if (c == 0.3)
			System.out.println("Eşit");
		else
			System.out.println("Eşit değil");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	13 Şubat 2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Yazılar da aslında bilgisayar belleğinde 2'lik sistemde sayılar biçiminde tutulmaktadır. Bir yazıyı oluşturan 
	elemanlara "karakter" denilmektedir. İşte bir yazıda her bir karakter 2'lik sistemde bir sayı ile ifade edilir. Böylece yazı 
	aslında ikilik sistemde bir sayı dizisi gibi tutulmaktadır. İşte bir karakter için hangi sayının karşı geldiğini belirten 
	tablolara "karakter tabloları" denilmektedir. Karakter tablosundaki karakter şekillerine "glyph" denilmektedir. Her karaktere 
	tabloda bir sıra numarası verilmiştir. Buna da "code point" denilmektedir. Dünyanın ilk standart karakter tablosu 
	"ASCII (American Standard Code Information Interchange)" denilen tablodur. ASCII tablosu aslında 7 bit bir tablodur. Dolayısıyla
	tabloda 128 tane glyph için code point bulundurulmuştur. ASCII dışında IBM EBCDIC tablosunu geliştirmiştir. Wang firması WISCII
	tablosunu kullanmıştır. ASCII tablosu Amerikalılar tarafından yalnızca İngilizce karakterleri ifade etmek için oluşturulmuştur. 
	Bilgisayarlar yaygınlaşmaya başladığında farklı karakterlere sahip olan Türkiye gibi, Yunanistan gibi, Almanya gibi ülkeler bu 
	ASCII tablosunu 8 bite çıkartıp elde edilen 128'lik yeni alanı kendi karakterlerini ifade etmek için kullanmışlardır. ASCII tablosunun
	ilk yarısı (yani [0, 128] numaraları karakterleri) standarttır. Ancak ikinci yarısı "code page" adı altında farklı ülkeler tarafından 
	farklı yerleşimler yapılarak kullanılmaktadır. DOS zamanlarında Türkçe karakterler için OEM 857 denilen code page kullanılıyordu. Daha 
	sonra Microsoft Windows sistemlerinde Türkçe karakterler için 1254 code page'i düzenledi. ISO, bu code page'leri standart hale 
	getirmiştir. Bugün Türkçe karakterler ISO tarafından ASCII 8859-9 Code page'i ile düzenlenmiştir. ASCII tablosu ve onların 
	code page'leri uzun süre kullanılmış ve hala kullanılmakta olsa da maalesef karışıklıklara yol açmaktadır. İşte son 20 yıldır artık 
	karakterleri 2 byte içerisinde ifade ederek dünyanın bütün dillerinin ve ortak sembollerinin tek bir tabloya yerleştirilmesi ile ismine 
	UNICODE denilen bir tablo oluşturulmuştur (www.unicode.org). UNICODE tablo ISO tarafından 10646 ismiyle de bazı farklılıklarla standardize 
	edilmiştir. UNICODE tablonun ilk 128 karakteri standart ASCII karakterleri, ikinci 128 karakteri ISO 8859-9 code page'indeki 
	karakterlerdir. Bir karakter tablosundaki code point'lerin ikilik sistemde ifade edilme biçimine "encoding" denilmektedir. ASCII 
	code page'lerinde encoding doğrudan code point'in 1 byte'lık sayı karşılığıdır. Ancak UNICODE tablonun değişik encoding'leri 
	kullanılmaktadır. UNICODE tablonun klasik encoding'i UTF-16'dır. Burada code point doğrudan 16 bit bir sayı biçiminde ifade 
	edilir. UTF-32 encoding'inde ise code point 32 bitlik bir sayı biçiminde ifade edilmektedir. Ancak UNICODE tablonun en yaygın 
	kullanılan encoding'i UTF-8 encoding'idir. UTF-8 kodlamasında standart ASCII karakterler 1 byte ile, diğer karakterler 2 byte, 
	3 byte, 4 byte ve 5 byte ile kodlanabilmekedir. Türkçe karakterler UTF-8 encoding'inde 2 byte yer kaplamaktadr. UTF-8 encoding'i 
	UNICODE bir yazının adeta sıkıştırılmış bir hali gibi düşünülebilir. Bugün pek çok programlama editörleri default durumda dosyayı 
	UNICODE UTF-8 encoding'ine göre saklamaktadır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Değişken, bellekte ayrılan bir bölge ile işlşem yapılmasını saplar yani o bölgeyi temsil eder. Bir değişken için
	bellekte yer ayrılma detayları ileride ele alınacaktır. Değişken bildiriminin genel biçimi şu şekildedir:
	
		<tür> <isim>;
		
	Java'da bir değişken kullanılmadan önce bildirilmelidir. Değişken ismi, değişken isimlendirme kurallarına uygun
	herhangi bir isim olabilir. Bir değişkene bildirim noktasında değer verilmesine "ilkdeğerleme (initialization)" 
	denir. Bir değişkenin derleyici tarafından görülebildiği kod aralığına "faaliyet alanı (scope)" denir. Bir 
	değişkenin bellekte kalma süresine yani yaratılmasıyla yok edilmesi arasında kalan süre "ömür (storage duration)"
	denir. Ömür kavramı "adresler" konusuyla birlikte ileride ele alınacaktır. 
	
	Java'da 3 çeşit değişken vardır:
	1. Yerel değişkenler (local variables)
	2. Parametre değişkenleri (paraameter  variables)
	3. Sınıf veri elemanları (member variables)
	
	Bir metot içerisinde { ile } arasında kalan bölgeye parantezler ile birlikte "blok (block)" denir. Bu anlamda 
	metodun gövdesi de bir bloktur. Bir metot içerisinde istenildiği kadar içiçe veya ayrık bloklar olabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {

	public static void main(String[] args) 
	{
		
		int a = 10; //initialization
		double b;
		
		b = 10;
		
		//...
		
		a = 20;
		
		{
			//...
			
			{
				
			}
			{
				//...
				{
					
				}
			}
		}
		
		{
			//...
		}
			
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir blok içerisinde bildirilen değişkenlere yerel değişkenler (local variables) denir. Eğer yerel değişkenler
	aynı türdense bu durumda bildirim virgül ile ayrılarak yapılabilir. Yerel bir değişkenin faaliyet alanı (scope)
	bildirildiği yerden bildirildiği bloğun sonuna kadardır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {

	public static void main(String[] args) 
	{
		int a, x = 10, y;
		
		//...
			
	}
}

class Sample {
	public static void foo()
	{
		a = 10; //error
		int b;
		
		{
			int c;
			//...
			
			c = 34;
			
			b = 23;
		}
		
		b = 34;
		c = 10; //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aynı faaliyet alanı içerisinde aynı isimde yerel değişken bildirimi yapılamaz. 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo()
	{
		int a;
		double a; //error
		
		{
			float a; //error
			
			//...
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Farklı faaliyet alanları içerisinde aynı isimde yerel değişken bildirimi geçerlidir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {

	public static void main(String[] args) 
	{
		int a;
		
		//...
	}
}

class Sample {
	public static void foo()
	{
		int a;
	

		{
			int b;
			//..
		}
		
		int b;
		
		//...
	}
	
	public static void bar()
	{
		int a;
		
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	System.out.println, System.out.print metotları aldıkları değişkenin değerini akrana basarlar  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		int a = 10;
		double b = 3.4;
		
		System.out.println(a);
		System.out.println(b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java'da değer verilmemiş bir değişken kullanılamaz. Yerel değişkenlere otomatik olarak değer verilmez. Yerel bir 
	değişkenin kullanılması için faaliyet alanı içerisinde en az bir kez programcı tarafından değer verilmiş olması 
	gerekir  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {

	public static void main(String[] args) 
	{
		int a; 
		int b;
		
		b = a; //error
			
		System.out.println(a); //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Programlamada artık kullanılması önerilmeyen bir kavrama deprecated denir. Deprecated olmanın
	çeşitli gerekçeleri olabilir. Programcı deprecated olan bir şeyi özel bir durum yoksa kullanmamalıdır. Deprecated
	olmanın gerekçeleri ve yerine kullanılacak şeyler dökumante edilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Değişken isimlendirme kuralları (Buradaki kurallar tüm değişken atomlar için geçerlidir):
	- Değişken isimleri bir rakam karakteri ile başlatılamaz. Uygun bir karakter ile başlatılıp istenildiği kadar
	rakam karakteri kullanılabilir.
	
	- Değişken isimlerinde alfabetik karakter kullanılabilir.
	
	- Değişken isimlerinde "_ (underscore)" karakteri kullanılabilir. Değişken ismi alttire karakteri ile de başlatılabilir.
	Java 8 ile brilikte _ karakterinin tek başına değişken ismi olması deprecated olmuştur, Java 9 ile birlikte _
	karakterinin tek başına kullanımı error olarak değğerlendirilir.
	
	- Anahtar sözcükler tek başına değişken ismi olamazlar.
	Anahtar Notlar: Java'ya daha sonraya eklenen bazı sözcükler kullanım yerine anahtar sözcük ya da değişken gibi ele 
	alınırlar. Aslıunda bu tip sözcükler JLS'de anahar sözcükler listesinde bulunmaz. Bu tip sözcüklere programlamada 
	"contextual keywords" denilmektedir.
	
	- Değişken isimleri bir boşluk (whitespace) karakteri içeremez.
	
	- Değişken isimleri byük-küçük harf duyarlıdır (case sensitive). Aslında Java case sensitive bir dildir. Örneğin
	anahtar sözcüklerin tamamı küçük garf olarak yazılmalıdır.
	
	- Değişken isimleri UNICODE alfabetik karakterler içerebilir. Örneğin değişken isimlerinde Türkçe karakterler kullanılabilir.
	Anahtar Notlar: Her ne kadar değişken isimlerinde UNICODE alfabetik karakterler kullanılabilse de programcı İnglizce
	alfabedeki karakteri tercih etmelidir. Hatta programcı bir değişken ismi herhangi bir dile özgü de yazmamalıdır. Değişken
	isimlerinde İnglizce kelimer tercih edilmeldir.
	
	- Değişken isimlerinde $ karakteri kullanılabilir. Değişken ismi $ karakteri ile başlatılabilir, $ karakteri tek
	başına değişken ismi olabilir. Derleyiciler bazı durumlarda arakoda veya arakod içerisinde isimler verirler. Derleyiciler
	bu tip isimleri verirken $ karakterini de kullanırlar. Java programcısı da hiç bir zaman $ karakterini değişken 
	isimlerinde kullanmaz. Bu durumda programcının belirlediği isimler ile derleyicinin belirlediği isimlerin çakışma
	olaslığı olmaz. Zaten $ karakteribin değişken isimlendirmede kullanılabilmesinin nedeni yani varlık sebebi budur. 
	JLS'de de $ karakteri bu şekilde açıklanmış ve programcı tarafından kullanılması önerilmemiştir
	
	- Değişken isimlerinin okunabilirlik/algılanabilirlik açısından "kolay telaffuz edilebilir, anlamlı ve yeterince uzunlukta"
	olması önerilir. Bu genel bir programlama "convention"'ı olarak düşünülmelidir. Değişken isimlendirmede bazı teknikler de
	kullanılabilmektedir. Genel olarak kullanılan programlama diline göre bir ya da birden fazla teknik kullanılabilmektedir.
	
	- JLS'de değişken isimlerinin maksimum karakter sayısı ile ilgili herhangi bir söylenmemiştir. Şüphesiz bir sınıfı
	olur. Ancak bu sınır oldukça fazla olma eğiliminde olduğundan isimlendirmede bir sorun oluşturmaz.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	15 Şubat 2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java'da klavyeden okuma yapmak (aslında stdin'den okuma yapmak) için pek çok sınıf ve metot bulunmaktadır. Biz kursumuzda
	ağırlıklı olarak Scanner isimli bir sınıfın nextXXX metotlarını kullanacağız. Belirli konulara gelene kadar bu 
	kullanımlar birer kalıp biçiminde düşünülmelidir. Kullanılan kalıpların detayları ileride anlaşılacaktır. Kullanılan
	kalıplarda IDE'nin static kod analizi ya da derleyici bir takım uyarılar (warnings) verebilecektir. Aksi belirtilmediği 
	sürece bu uyarılar dikkate alınmayacaktır.
	
	Bu kalıplarda ilgili türden giriş yapılmadığı durumlarda exception oluşur.	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki klavyeden int türden değer okuma kalıbında değerler aralarında en az bir tane whitespace karakter olacak
	şekilde girilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int total;
		
		total = a + b;
		System.out.println(total);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki klavyeden int türden değer okuma kalıbında değerler ENTER karakteri ile ayrılacak şekilde girilmelidir. 
	Diğer whitespace karakterlerin kullanımı exception oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine()); 
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		int total;
		
		total = a + b;
		System.out.println(total);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki klavyeden double türden değer okuma kalıbında değerler aralarında en az bir tane whitespace karakter olacak
	şekilde girilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		double total;
		
		total = a + b;
		System.out.println(total);		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki klavyeden double türden değer okuma kalıbında değerler ENTER karakteri ile ayrılacak şekilde girilmelidir. 
	Diğer whitespace karakterlerin kullanımı exception oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayıyı giriniz:");
		double a = Double.parseDouble(kb.nextLine()); 
		
		System.out.print("İkinci sayıyı giriniz:");
		double b = Double.parseDouble(kb.nextLine());
		double total;
		
		total = a + b;
		System.out.println(total);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki klavyeden long türden değer okuma kalıbında değerler aralarında en az bir tane whitespace karakter olacak
	şekilde girilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		long a = kb.nextLong();
		long b = kb.nextLong();
		long total;
		
		total = a + b;
		System.out.println(total);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki klavyeden long türden değer okuma kalıbında değerler ENTER karakteri ile ayrılacak şekilde girilmelidir. 
	Diğer whitespace karakterlerin kullanımı exception oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayıyı giriniz:");
		long a = Long.parseLong(kb.nextLine()); 
		
		System.out.print("İkinci sayıyı giriniz:");
		long b = Long.parseLong(kb.nextLine());
		long total;
		
		total = a + b;
		System.out.println(total);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İfade (expression): Sabitlerden, operatörlerden ve değişkenlerden oluşan herhangi bir kombinasyona ifade denir. Bir
	ifade yalnızca sabitlerden ve operatörlerden oluşuyorsa bu ifadeye "constant expression" denir. Bir değişken veya sabit
	tek başına ifadedir. Ancak bir operatör tek başına bir ifade olamaz. Her ifadenin bir türü vardır. Bunun bir tane 
	istisnası vardır, ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri bilgisi yerine bir tür ismi yazılırsa, bu metodun geri dönüş değeri (return value)"
	vardır denir. Tersinde bir metodun geri dönüş değeri varsa geri dönüş değeri bilgisi yerine bir tür yazılır. Bir 
	metodun geri dönüş değeri varsa, o metodun çağrısı bittiğinde çağrılan noktaya bir değer ile geri döner. Bir metodun
	geri dönüş değeri yoksa geri dönüş değeri bilgisi yerine void anahtar sözcüğü yazılır. Metodun geri dönüş değeri yoksa
	sonlandığında çağrılan noktaya yalnızca geri döner, bir değer aktarılmaz. Bir metodun geri dönüş değeri metot içerisinde 
	return deyimi ile oluşturulur. return deyiminin genel biçimi şu şekildedir:
	
		return [ifade];
		
	Görüldüğü gibi return deyimi tek başına veya bir ifade ile kullanılabilir. Bu kullanımların detayları bölüm içerisinde
	anlaşılacaktır. return deyimi nasıl kullanılırsa kullanılsın, akış return deyimine geldiğinde metot sonlanır. Yani 
	return deyiminin birinci görevi metodu sonlandırmaktır. return deyimi ifade ile kullanılmışsa ifadenin değeri çağrılan
	noktaya aktarılır. Buna geri dönüş değeri denmesinin nedeni budur  
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte add metodu çağrıldığında kullanıcıdan iki değer istenmiş ve o değerlerin toplamına geri 
	dönülmüştür. main metodu içerisinde ise add metodu çağrılmış, geri dönüş değeri 3 ile çarpılıp sonuç result 
	değişkenine atanmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		int result;
		
		result = Util.add() * 2;
		
		System.out.println(result);						
	}
}

class Util {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int total;
		
		total = a + b;
		
		return total;		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan bir metot içerisinde return deyiminin tek başına kullanımı geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Util {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int total;
		
		total = a + b;
		
		return;	//error	
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan bir metot içerisinde akışın her noktasında metodun return edebilmesi gerekir. Yani derleyici
	açısından, metodun geri dönüş değeri varsa metot içerisinde metodun bir değer döndüremeyeceği bir durum oluşmamalıdır 
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte geri dönüş değeri olan add metodunda bir değer döndürülmediği için error oluşur 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Util {
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int total;
		
		total = a + b;	
			
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte geri dönüş değeri olan add metodunda total > 10 koşulu gerçeklenmediğinde metot bir değere 
	dönemeyeceğinden dolayı error oluşur 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Util {
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int total;
		
		total = a + b;
		
		if (total > 10)
			return total;	
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demoörnekte return deyimine ilişkin ifadenin değeri a ile b'nin değerlerinin toplamından elde edilmiştir. Bu
	tarz ifadelerde okunabilirliğin/algılanabilirliğin olumsuz etkilenmemesine dikkat edilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		int result;
		
		result = Util.add() * 2;
		
		System.out.println(result);						
	}
}

class Util {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte add metodunun geri dönüş değeri getInt metodunun geri dönüş değeri yapılmıştır. Yani, getInt
	metodu add metodu çağrıldıktan sonra elde edilen değere geri dönmektedir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		int result;
		
		result = Sample.getInt();
		
		System.out.println(result);						
	}
}

class Sample {
	public static int getInt()
	{
		System.out.println("İki tane tamsayı değeri girmeniz gerekiyor:");
		
		return Util.add();
	}
}

class Util {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		return a + b;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Metot çağrısı için derleyici geçici değişken (temporary variable) yaratan ve işleme sokulan bir kod üretir. Geçici
	değişkenin türü çağrılan metodun geri dönüş değeri türü ile aynıdır. Aşağıdaki demo örnekte *** ile belirtilen 
	deyimi için üretilen yaklaşık kod şu şekildedir:
		int temp = Util.add();
		
		result = temp * 2;
	
	Bu durumda geri dönüş değeri olan bir metot çağrısı geçici değişkene yapılan bir atama işlemidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		int result;
		
		result = Util.add() * 2; //***
		
		System.out.println(result);						
	}
}

class Util {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan bir metot geri dönüş değeri yokmuş gibi yani geri dönüş değeri işleme sokulmadan çağrılabilir.
	Şüphesiz metodun da buna uygun olması gerekir. Aşağıdaki demo örnekte add metodu toplam değerini ekrana bastığı için
	ve add metodunu çağıran kod da yalnızca ekrana basmı kısmı ile ilgilendiği için metodu doğrudan çağırmaktadır. Demo
	örnekteki add metodu toplam değerini ekrana basmasaydı, yani sadece geri döndürseydi, doğrudan çağrılmasının 
	algoritmik açıdan etkisi olur muydu?
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		Util.add();
	}
}

class Util {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int total = a + b;
		
		System.out.println(total);
		
		return total;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	20 Şubat 2024	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri yoksa geri dönüş değeri bilgisi yerine "void" anahtar sözcüğü yazılır. Geri dönüş
	değeri olmayan metotlara "void method" da denilmektedir. void bir metot sonlandığında çağrılan noktaya bir değer 
	ile dönmez. Bu durumda void metot içerisinde return deyimi bir ifade ile kullanılamaz. İstenirse metodu sonlandırmak
	için tek başına kullanılabilir. Bu anlamda void metotlarda return deyimi zorunlu değildir. void bir metot geri dönüş
	değeri varmış gibi çağrılamaz. Yani geri dönüş değeri varmış gibi işleme sokulamaz 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		Util.printTotal();
	}
}

class Util {
	public static void printTotal()
	{
		int total = add();
		
		System.out.println(total);
	}	
	
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int total = a + b;		
		
		return total;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;


class Util {
	public static void printTotal()
	{
		int total = add();
		
		System.out.println(total);
		
		return total; //error
	}	
	
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int total = a + b;		
		
		return total;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		Util.printTotal();
	}
}

class Util {
	public static void printTotal()
	{
		int total = add();
		
		if (total <= 0)
			return;		
		
		System.out.println(total);		
	}	
	
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int total = a + b;		
		
		return total;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		int result = Util.printTotal() * 2; //error
		
				
	}
}

class Util {
	public static void printTotal()
	{
		int total = add();
		
		if (total <= 0)
			return;		
		
		System.out.println(total);		
	}	
	
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int total = a + b;		
		
		return total;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		int result = Util.printTotal() * 2; //error
				
	}
}

class Util {
	public static void printTotal()
	{
		int total = add();		
	
		System.out.println(total);		
	}	
	
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int total = a + b;		
		
		return total;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: void bir metot çağrısı da bir ifadedir. Ancak bu ifadenin türü yoktur. void bir metot çağrısına 
	ilişkin ifadelere "void expressions" denilmektedir 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Bir metodun geri dönüş değeri o metodun bir çıktısıdır (output).  	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Java'da bir metot bir tane değere geri dönebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Metodun gövdesinde önce parantez içerisinde bildirilen değişkenlere metot parametre değişkenleri denir. Metot 
	parametre değişkenleri virgül ile ayrılır. Değişkenler aynı türden olsa bile tür bilgisi her biri için yazılmalıdır.
	Metot parametre değişkenleri faaliyet alanı olarak metodun başında bildirilen yerel değişkenler gibidir. Yani ilgili
	metot boyunca görülebilirdir. Metot çağrısında metoda geçilen ifadelere argüman (argument) denir. Bu anlamda metodun
	parametre değişkenleri aslında metodun girdileridir (input). Bir metodun kaç tane parametresi varsa o kadar sayıda
	argüman ile çağrılmalıdır. Parametre değişkenleri değerlerini metot çağrısında, ilgili parametreye geçilen ifadenin
	değeri olarak alırlar. Yani metot çağrısında argümana ilişkin ifade önce hesaplanır ve değeri parametre değişkenine
	aktarılır. Bu anlamda argümanlardan parametrelere aktarım da bir atama işlemidir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int x = kb.nextInt();
		int y = kb.nextInt();		
		int result;
		
		result = Util.add(x, y);
		
		System.out.println(result);
	}
}

class Util {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte b değişkeni tür bilgisi yazılmadığından error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Util {
	public static int add(int a, b) //error
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte 2 parametreli add metodu 3 tane argüman ile çağrıldığından error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int x = kb.nextInt();
		int y = kb.nextInt();		
		int result;
		
		result = Util.add(x, y, 10); //error
		
		System.out.println(result);
	}
}

class Util {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int x = kb.nextInt();
		int y = kb.nextInt();		
		int result;
		
		result = Util.add(x + 2, y * 2);
		
		System.out.println(result);
	}
}

class Util {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Java'da 3 yerde atama işlemi yapılır: 
	1. Yalın atama işlemi
	2. Metodun geri dönüş değerinin geçici değişkene atanması
	3. Argümandan parametre değişkene aktarım
	
	Özel bazı durumlar dışında atama işlemine ilişkin kurallar tüm atama işlemleri için geçerlidir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	22 Şubat 2024
----------------------------------------------------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------------------------------------------------
	Metotlar ne işe yarar? Ya da başka bir deyişle bir problemin çözümünde neden metotlar yazalım? 
	Aşağıda metot yazılmasına ilişkin durumlar genel olarak ele alınmıştır:
	
	- Bir işi çok fazla yerde yapmak kod tekrarına yol açar. Yazılım geliştirmede temel prensip olarak "zorunlu olmadıkça 
	kod  tekrarı yapılmamalıdır (do not repeat yourself)". Bu durumda programcı bir metot yazarak ilgili yerlerde o metodu 
	çağırır
	
	- Bir problemin çözümü metot çağırma yerine her yerde kodun yazılması biçiminde "implemente" edilmişse, bu durumda 
	programcı problemin çözümünde bir değişiklik yapmak isterse veya bir hata olduğunu görüp düzeltmek isterse her yerde
	bu değişiklikleri yapmak zorundadır. Bu da çoğu zaman zor olacaktır.
	
	- Bir problemin çözümü metot çağırma yerine her yerde kodun yazılması biçiminde "implemente" edilmişse, bu durumda
	kodun okunabilirliği/algılanabilirliği azalabilir. Yani metot çağırarak kodun okunabilirliği/algılanabilirliği artırılmış
	olur.
	
	- Metot yazıldığında başka projelere taşınarak da kullanılabilir (code reusability).
	
	- Metodu çağıran programcı metodun nasıl yazıldığına ilişkin detayları bilmek zorunda değildir. Çünkü metodun 
	çağrıldığı noktada metodun nasıl yazıldığının önemi yoktur. Ne yaptığı önemlidir.
	
	- Bir kod parçasının metot olarak yazılması onun bağımsız olarak test edilip doğrulanması veya varsa hataların
	düzeltilmesi açısından da önemlidir.
	
	Anahtar Notlar: Kurs içerisinde ele alacağımız Nesne Yönelimli Programlama Tekniği'ne (Object Oriented Programming Paradigm)
	ilişkin kavramlar ile kodun parçalara ayrılması metotlar dışında daha yüksek seviyede de yapılabilecektir. 
-----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	System.out.printf metodu ile formatlı yazdırma yapılabilir. printf metodunun birinci parametresine geçien argüman
	bir yazı (string literal vb.) olmalıdır. Bu metot birinci parametresi ile birlikte değişken sayıda argüman alabilecek
	şekilde tasarlanmıştır. Değişken sayıda argüman alan metotların (vararg methods) bildiriminin nasıl yapıldığı bu
	bölümde ele alınmayacaktır. printf metodunun birinci parametresine ilişkin yazının içerisinde % karakteri ile 
	birlikte özel bazı karakterler kullanılabilmektedir. Bu özel karakterlere format karakterleri (format specifiers)
	denir. Bir format karakterinin yazı içerisinde % karakteri ile birlikte kullanılmasına ise yer tutucu (place holder)
	denir. Bir format karakteri özel bazıları dışında bir türe karşılık gelir ve o yer tutucu yerine printf'e geçilen
	argümanların değerleri yerleştirilerek yazı formatlanır. Format karakterlerinin bazıları şunlardır:
	- d: Tamsayı türleri için kullanılır. Sayının değerinin decimal olarak formatlanmasını sağlar.
	- x veya X: Tamsayı türleri için kullanılır. Sayının değerinin hexadecimal olarak formatlanmasını sağlar.
	- h veya H: Tamsayı türleri için kullanılır. Sayının değerinin hexadecimal olarak formatlanmasını sağlar.
	- o: Tamsayı türleri için kullanılır. Sayının değerinin octal olarak formatlanmasını sağlar.
	- f: Gerçek sayı türleri kullanılır.  
	- c: char türü için kullanılır.
	- b: boolean türü için kullanılır.
	- n: İmleci (cursor) bir sonraki satırın başına çekmek için kullanılır.
	- %: % karakterinin karşılığıdır. 
	
	Bu format karakterleri dışında da format karakterleri vardır. Kurs boyunca konular içerisinde ele alınacaktır.
	Format karakterlerine ilişkin detaylar yine ileride ele alınacaktır.
	
	Anahtar Notlar: printf metodu gibi kullanılan ancak printf'den daha fazla karşımıza bazı metotlar için printf 
	metodunun formatlama detaylarının öğrenilmesi önemlidir 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	d, x, X, h, H ve o format karakterleri
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int x = kb.nextInt();
		int y = kb.nextInt();		
		
		System.out.printf("%d + %d = %d%n", x, y, x + y);
		System.out.printf("%x + %x = %x%n", x, y, x + y);
		System.out.printf("%X + %X = %X%n", x, y, x + y);
		System.out.printf("%h + %h = %h%n", x, y, x + y);
		System.out.printf("%H + %H = %H%n", x, y, x + y);
		System.out.printf("%o + %o = %o%n", x, y, x + y);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tamsayıya ilişkin format karakterlerinde % ile format karakteri arasında yazılan sayı hizalamak (alignment) için
	kullanılabilir. Bu sayının pozitif olması gerekir. % ile format karakteri arasında yalnızca pozitif bir sayı 
	sayı yazıldığında formatlanan sayının basamak sayısı % ile format karakteri arasındaki sayıdan küçükse soluna verilen
	sayı kadar space karakteri eklenir. Eğer % ile format karakteri arasında verilen sayıdan önce sıfır sayısı yazılırsa
	space yerine sıfır değeri ile formatlama yapılır. Tamsayılara ilişkin format karakterlerinin başka detaylı kullanımları da
	vardır. Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Tarih bilgisini gün ay yıl olarak giriniz:");
		int day = kb.nextInt();
		int month = kb.nextInt();		
		int year = kb.nextInt();
		
		System.out.printf("%02d/%02d/%04d%n", day, month, year);
		System.out.printf("%2d/%2d/%4d%n", day, month, year);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		System.out.printf("a = %d%na = %08X%n", a, a);
				
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	% karakterinin % olarak formatlanabilmesi için yine % karakteri ile kullanılması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int ratio = kb.nextInt();
		
		System.out.printf("Oran:%%%d%n", ratio);		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	f format karakteri
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		double ratio = kb.nextDouble();
		
		System.out.printf("Oran:%%%f%n", ratio);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	f format karakteri için % ile f arasında . ve pozitif bir sayı yazıldığında formatlanacak gerçek sayının noktadan 
	sonraki kısmının kaç basamak olarak gösterileceği belirlenir. Gerçek sayının geri kalan basamakları bilimsel 
	yuvarlanarak formatlanır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		double ratio = kb.nextDouble();
		
		System.out.printf("Oran:%%%.2f%n", ratio);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	c format karakteri
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		char c;
		
		c = 68;
		
		System.out.printf("c = %c%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	printf metodunda geçilen argümanların türleri ile uyumsuz format karakteri kullanılması durumunda genel olarak
	exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int day = kb.nextInt();
		
		System.out.printf("a = %f%n", day);			
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Tam sayılarla bölme işleminde elde edilen sonucun noktadan sonraki kısmı atılır. Yani tamsayılarla bölme işleminde
	sonuç yine tamsayı çıkar 
	
	Tam sayılarla bölme işleminde paydanın değeri sıfır ise exception oluşur.
	
	Aşağıdaki demo örneği çeşitli değerlerle çalıştırıp sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int c;
		
		c = a / b;
		
		System.out.printf("c = %d%n", c);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	IEEE 754 formatında bazı özel değerler bulunur. Bu değerler Matematiksel olarak bazı kavramları temsil ederler. Örneğin
	Infinity ve -Infinity sırasıyla Matemetikteki "artı sonsuz" ve "eksi sonsuz" değerlerine karşılık gelir. NaN değeri de
	Matematikteki belirsizliği (indeterminate) temsil eden değerdir. Bu durumda gerçek sayılarda bölme işleminde paydanın
	sıfır olması durumunda da işlem yapılabilmektedir. Aşağıdaki demo örneği çeşitli değerler ile çalıştırıp sonuçları 
	gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		double c;
		
		c = a / b;
		
		System.out.printf("c = %f%n", c);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	27 Şubat 2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Neden standart metotları kullanmalıyız? Standart olarak var olan bir metodu programcı yazmalı mıdır? 
	Java'da standart olarak (yani JavaSE'de bulunan) metotlatın kullanılmasının bazı önemli avantajları şunlardır:
	- Okunabilir/algılanabilir kodlar yazılır
	
	- Testleri yapılmıştır ve yeterince etkin olarak yazılmıştır. Hatta zamanla duruma göre daha etkin hale getirilecek
	şekilde yazılabilmektedir.
	
	- Taşınabilirdir. Yani standart metotların çağrıldığı kodlar herhangi bir üçüncü parti koda ya da kütüphaneye
	ihtiyaç duymadan derlenebilir.
	
	 - Programcının bir uygulama geliştirirken yalnıca uygulamaya ilişkin domain'e odaklanmasını sağlar. 
	 
	 - Bazı metotları yazmak için başka detay konuların da bilinmesi gerekir.
	 
	
	Bu durumda bir Java programcısının çözmesi gereken bir problem için, JavaSE'de problemin çözümüne ilişkin metotlar
	varsa onları kullanması gerekir, yoksakullandığı bazı iyi kütüphanelerin içerisinde varsa onu kullanması gerekir. 
	Burada da yoksa bu durumda programcı o metodu yazmalıdır. Ancak bu durum programcının kullandığı bir metodu
	standart olsun ya da olmasın nasıl yazıldığını gözardı etmesi anlamına gelmemelidir. Programcı programlama yaşamı
	boyunca hepsini olmasa da hazır olarak kullandığı metotların nasıl yazıldığını (implementation) öğrenmesi gerekir.	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Bir metodun ne iş yaptığına ilişkin detaylar nasıl öğrenilecektir? Bunun için tipik olarak metot
	için bir dökumantasyon oluşuturur. JavaSE içerisinde bulunan standart metotların (ait olduğu sınıfların da) 
	dökumantasyonu "docs.oracle.com" sitesinde çeşitli sayfalarda yayınlanmaktadır. Ancak yine de ilgili dökumantasyon
	tüm detayıyla öğretemeyebilir. Genel olarak Java dökumanları (javadoc) konu hakkında fikir vermek için yazılır.
	Duruma göre programcı başka kaynaklardan öğrenmek zorunda kalabilir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	java.lang paketi içerisinde bulunan Math sınıfının Matematiksel işlemlere yönelik çeşitli metotları vardır. Bu 
	metotların bazıları pek yerde kullanılır. Bazıları ise Matematiksel işlemlerde kullanılır. Burada çok kullanılan
	bazıları ele alınacaktır. Java programcısı Matematiksel işlemler gerektiğinde önce bu sınıfa bakmalı varsa bu 
	sınıfın elemanlarını kullanmalıdır. 
	
	Anahtar Notlar: java.lang paketi içerisinde bulunan sınıf isimleri doğrudan kullanılabilir. Konunun detayları
	ileride ele alınacaktır.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının sqrt metodu parametresi ile aldığı double türden değerin kareköküne geri döner. sqrt metoduna negatif
	bir argüman geçildiğinde NaN değerine geri döner
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();
		
		System.out.printf("sqrt(%f) = %f%n", a, Math.sqrt(a));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının pow metodu kuvvet almak için kullanılır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Tabanı ve üssü giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		
		System.out.printf("pow(%f, %f) = %f%n", a, b, Math.pow(a, b));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı double türden iki noktaya ilişkin koordinat bilgilerine göre iki nokta
	arasındaki Euclid uzaklığına geri dönen distance isimli metodu PointUtil isimli sınıf içerisinde yazınız ve aşağıdaki
	kod ile test ediniz
	
	Euclid Uzaklığı fomulü: sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2) 
	Açıklama: ^ üs anlamına gelmektedir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		PointUtilDistanceTest.run();
	}
}

class PointUtilDistanceTest {
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki noktanın koordinatlarını giriniz:");
		double x1 = kb.nextDouble();
		double y1 = kb.nextDouble();
		double x2 = kb.nextDouble();
		double y2 = kb.nextDouble();
		double d = PointUtil.distance(x1, y1, x2, y2);
		
		System.out.printf("distance(%f, %f, %f, %f) = %f%n", x1, y1, x2, y2, d);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class PointUtil {
	public static double distance(double x1, double y1, double x2, double y2)
	{
		return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı double türden iki noktaya ilişkin koordinat bilgilerine göre iki nokta
	arasındaki Euclid uzaklığına geri dönen distance isimli metodu PointUtil isimli sınıf içerisinde yazınız ve aşağıdaki
	kod ile test ediniz
	
	Euclid Uzaklığı fomulü: sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2) 
	Açıklama: ^ üs anlamına gelmektedir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		PointUtilDistanceTest.run();
	}
}

class PointUtilDistanceTest {
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki noktanın koordinatlarını giriniz:");
		double x1 = kb.nextDouble();
		double y1 = kb.nextDouble();
		double x2 = kb.nextDouble();
		double y2 = kb.nextDouble();
		double d = PointUtil.distance(x1, y1, x2, y2);
		
		System.out.printf("distance(%f, %f, %f, %f) = %f%n", x1, y1, x2, y2, d);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class PointUtil {
	public static double distance(double x1, double y1, double x2, double y2)
	{
		return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	29 Şubat 2024
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	 Math sınıfının logaritma fonksiyonuna ilişkin metotları şunlardır: log, log10, log1p. 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();
		
		System.out.printf("log(%f) = %f%n", a, Math.log(a));
		System.out.printf("log10(%f) = %f%n", a, Math.log10(a));
		System.out.printf("log1p(%f + 1) = %f%n", a, Math.log1p(a));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		
		System.out.printf("log(%f, %f) = %f%n", a, b, MathUtil.log(a, b));
	}
}

class MathUtil {
	public static double log(double a, double b)
	{
		return Math.log(b) / Math.log(a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Math sınıfının PI ve E elemanları
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		System.out.println(Math.PI);
		System.out.println(Math.E);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının trigonometrik işlem yapan metotları radyan (radians) ölçü birimiyle çalışırlar
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Derece bilgisini giriniz:");
		double a = kb.nextDouble();
		
		System.out.printf("sin(%f) = %f%n", a, Math.sin(Math.toRadians(a)));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının abs metotları
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		System.out.printf("|%d| = %d%n", a, Math.abs(a));
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının min ve max metotları
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		System.out.printf("min(%d, %d) = %d%n", a, b, Math.min(a, b));
		System.out.printf("max(%d, %d) = %d%n", a, b, Math.max(a, b));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının min ve max metotları ile 3 tane sayının en küçüğünün ve en büyüğünün bulunması 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Üç sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int c = kb.nextInt();
		
		System.out.printf("min(%d, %d, %d) = %d%n", a, b, c, Math.min(Math.min(a, b), c));
		System.out.printf("max(%d, %d, %d) = %d%n", a, b, c, Math.max(Math.max(a, b), c));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının tamsayı değerine yuvarlayan önemli bazı metoları 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();
		
		System.out.printf("round(%f) = %d%n", a, Math.round(a));
		System.out.printf("round(%f) = %f%n", a, Math.rint(a));
		System.out.printf("ceil(%f) = %f%n", a, Math.ceil(a));
		System.out.printf("floor(%f) = %f%n", a, Math.floor(a));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	5 Mart 2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sabitler (Literals): Program içerisinde doğrudan yazılan bir değere sabit (literal/constant) denir. 
	
	Anahtar Notlar: Anımsanacağı gibi iki tırnak içerisindeki yazılara "string literal" denir.
	
	Sabitlerin de türleri vardır. Sabitlerin türleri derleme aşamasında yani derleyici tarafından tespit edilir.
	
	Anahtar Notlar: Derleyicinin bir ifadenin türünü tespit etmesine genel "type inference/deduction" denilmektedir.
	
	Sabitlerin türleri aşağıdaki kurallara göre belirlenir:
	- Sayı nokta içermiyorsa, sonuna herhangi bir ek almamışsa ve int türü sınırları içerisinde kalıyorsa int türden 
	bir  sabittir. Sayı, nokta içermiyorsa fakat int türü sınırları dışındaysa error oluşur. 
	Örnekler: 100, 2000000000 vb.
	
	- Sayı nokta içermiyorsa ve sonuna L (küçük veya büyük harf olarak) son ekini almışsa long türdendir. L sonekini
	almış bir sabit long türü sınırları dışındaysa error oluşur. 
	Örneğin, 10L, 4000000000L vb.
	
	Anahtar Notlar: Küçük harf L soneki 1(bir) sayısına özellikle bazı yazı türlerinde benzediği okunabililik açısından
	kullanılması tavsiye edilmez.
	
	- Java'da byte ve short türden sabit yoktur
	
	- Sayı nokta içeriyorsa ve sonuna herhangi bir ek almamışsa double türdendir. 
	Örneğin: 3.4, 6.6 vb.
	
	- Sayı nokta içersin ya da içermesin sonuna D (küçük veya büyük) ekini alıyorsa double türdendir.
	Örneğin: 4.5D, 5D, 5.6d vb.
	
	- Sayı nokta içersin ya da içermesin sonuna F (küçük veya büyük) ekini alıyorsa float türdendir. 
	Örneğin: 3.4F, 7f, 6.8F vb.
	
	Anahtar Notlar: Nokta içeren ve noktadan sonraki kısmın tamamı sıfır olmayan bir sabitin (yani double türden sabitin)
	sonuna F (küçük veya büyük) eki getirildiğinde, sayının değeri float türü ile temsil edilemiyorsa en yakın değere
	yuvarlanır (rounding error). 
	
	- boolean türden iki tane sabit vardır: true, false.
	
	- Tek tırnak içerisinde yazılan karaterlere ilişkin sembollere tırnaklarıyla beraber karakter sabitleri (character literals).
	Karakter sabitleri char türdendir. Tek tırnak içerisinde özel bazı durumlar dışında tek bir karakter yazılır. Aksi durumda 
	error oluşur. Bir karakter sabiti ilgili karakterin karakter tablosundaki sıra numarasına karşılık gelir. Aslında biz
	char türden sabit yazarak o sabite ilişkin karakterin sıra numarasını elde etmiş oluruz. Bu sıra numarasını char
	türden bir değişken içerisinde saklayarak mantıksal olarak o karakteri tutmuş oluruz. Bazı karakterler klavyedeki
	tuş kombinasyonları ile doğrudan yazılamazlar. Bazı karakterler ise doğrudan ekrana basılamazlar (non-printable). 
	Bu tarz karakterler doğrudan tek tırnak içerisinde karakter sabiti olarak yazılamazlar. Bu karakterler ters bölü 
	karateri ile birlikte özel bir karakter kullanılarak tek tırnak içerisinde yani karakter sabiti olarak yazılırlar. 
	Ters bölü ile yazılan karakterlere "escape sequence" karakterler denir. Java'da desteklenen escape sequence karakterler 
	şunlardır:
	'\n'	-> Line Feed (LF)
	'\r'	-> Carriage Return (CR)
	'\t'	-> Tabular (horizontal tab)
	'\f'	-> Form feed
	'\b'	-> backspace
	'\''	-> single quote
	'\"'	-> double quote (optional)
	'\\'	-> back slash	
	
	Escape sequence karakterler string literal içerisinde kendi anlamlarındadır. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Line Feed karakter sabiti
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		char c;
		
		c = '\n';
		
		System.out.print("Hello, World");
		System.out.print(c);
		System.out.println("Goodbye, World");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Carriage Return karakter sabiti. 
	Dikkat: Aşağıdaki örneği işletim sisteminizin "komut yorumlayıcı" programı ile çalıştırınız. Kullandığınız IDE'nin
	console penceresi farklı yorumlayabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		char c;
		
		c = '\r';
		
		System.out.print("Hello, World");
		System.out.print(c);
		System.out.println("Hi");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Tek tırnak karakter sabiti ters bölü ile yazılır yani bu karakter sabiti de bir escape sequence karakterdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		char c;
		
		c = '\'';
		
		System.out.println(c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İki tırnak karakter sabiti iki şekilde yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		char c1, c2;
		
		c1 = '\"';
		c2 = '"';
		
		System.out.println(c1);
		System.out.println(c2);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Ters bölü karakter sabiti de escape sequence karakter olarak yazılır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{
		char c;
		
		c = '\\';	
		
		System.out.println(c);		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte LF karakteri string literal içerisinde kullanılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{		
		System.out.println("Hello\nWorld");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz. Örnekte tab ve LF karaktersabitlerinin yazı içerisinde kullanıldığına dikkat
	ediniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{		
		System.out.println("C:\test\names.txt");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz. Örnekte ters bölü karakteri için escape sequence kullanıldığına dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{		
		System.out.println("C:\\test\\names.txt");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String literal içerisinde ters bölü ile birlikte escape sequence olarak desteklenmeyen bir karakter kullanımı error
	oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{		
		System.out.println("C:\virtual\names.txt"); //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{		
		System.out.println("\\\\test\\names.txt");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Tek tırnak karakteri string literal içerisinde doğrudan ya da escape sequence olarak kullanılabilir. İki kullanım
	tamamen aynı anlamdadır. İki tırnak karakteri string literal içerisinde ancak escape sequence olarak kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{		
		System.out.println("'zonguldak'");
		System.out.println("\'zonguldak\'");
		System.out.println("\"zonguldak\"");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String literal içerisinde ters bölü ile birlikte escape sequence olarak desteklenmeyen bir karakter kullanımı error
	oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{		
		System.out.println("C:\virtual\names.txt"); //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{		
		System.out.println("`zonguldak`");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Java 12 ile birlikte ismine "text block" denilen bir string sabiti yazma yöntemi de eklenmiştir.
	Text block'lar ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sayının noktadan sonraki kısmı yani ondalık kısmının tamamı sıfırsa noktadan sonra sıfır yazılmayabilir. Benzer 
	şekilde sayının noktadan önceki kısmı yani tam kısmının tamamı sıfırsa noktadan önce sıfır yazılmayabilir. Yani
	1.0 sabiti ile 1. sabiti birebir aynıdır, benzer şekilde 0.1 sabiti ile .1 sabiti birebir aynıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{		
		System.out.println(1.);
		System.out.println(1.0);
		System.out.println(0.1);
		System.out.println(.1);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sabitlerin bilimsel/üstel gösterilişi. Bu şekilde yazılan sabitler double türdendir  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{		
		System.out.printf("%.0f%n", 6.02E23);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sabitlerin bilimsel/üstel gösterilişi. Bu şekilde yazılan sabitler double türdendir  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{		
		System.out.printf("%.0f%n", 6.02e23);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 7 ile birlikte sabitlerin basamakları arasında _ (alttire) karakteri kullanılabilir duruma gelmiştir. Alttire
	karakteri yalnızca basamaklar arasında istenildiği kadar kullanılabilir. Bu kullanım duruma göre okunabilirliği
	artırır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{		
		int a = 1_111_237_809;
		double b = 345_789.987_789;
		
		System.out.printf("a = %d, b = %f%n", a, b);	
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tamsayı sabitleri decimal dışında, hexadecimal, octal ve Java 7 ile birlikte binary olarak gösterilebilmektedir.
	Sabitin başında bir ek yoksa decimal, 0x (x küçük veya büyük olabilir) varsa hexadecimal, sıfır varsa octal ve 
	0b (b küçük veya büyük olabilir) binary olarak ele alınır. Şüphesiz sayının basamakları sayı sistemine uygun 
	olmalıdır. Aksi durumda error oluşur. Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{		
		int a = 10;
		int b = 0xA;
		int c = 012;
		int d = 0b1010; //Since Java 7
		
		System.out.printf("a = %d, b = %d, c = %d, d = %d%n", a, b, c, d);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sayı sistemi ile gösterilişte de alttire karakteri konabilir. Alttire karakteri basamakların arasına gelebileceğinden
	sabitin önekinden önce veya sonra kullanılması error oluşuturur. Bunun bir tek istisna durumu octal sabitin öneki
	olan sıfır'dan sonra alttire karakteri konabilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte sabitin octal olarak yazıldığına dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String[] args) 
	{		
		int a = 012;
		
		
		System.out.printf("a = %d%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	7 Mart 2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Operatörler (Operators): Belirli bir işleme yol açan, işlem sonucunda bir değer üreten atomlardır. Bir operatör ile
	işleme giren ifadelere (expression) operand denir. Bir operatörün öğrenilmesi için aşağıdaki özelliklerin incelenmesi
	gerekir:
	- Operatörün sınıfları:
		1. İşlevine göre sınıflandırma
			- Aritmetik operatörler (arithmetic operators)
			- Karşılaştırma operatörleri (comparison operators)
			- Mantıksal operatörler (logical operatörs)
			- Bitsel operatörler (bitwise operators)
			- Özel amaçlı operatörler (special purpose operators)
		2. Operand sayısına göre sınıflandırma
			- Tek operandlı (unary)
			- İki operandlı (binary)
			- Üç operandlı (ternary)
		3. Operatörün konumuna göre sınıflandırma
			- Önek (prefix)
			- Araek (infix)
			- Sonek (postfix)
			
	- Operatörün ürettiği değer (product value): İşlem sonucunda elde edilen değerdir.
	
	- Operatörün kısıtı (constraint): Operatörün kullanımına ilişkin bir takım zorunluluklardır.
	
	- Operatörün yan etkisi (side effect): Operatörün, operandının değerini değiştirip değiştirmediğidir.
	
	- Operatörün önceliği (precedence): Operatörün ifadede diğer operatörlere göre işlem sırasıdır. Örneğin
		 	x = y + z * t
		 işleminin yapılış sırası şöyledir:
		 	i1: z * t
		 	i2: y + i1
		 	i3: x = i2
		 Bir işlemi önceliklendirmek için Matematik'teki gibi önceliklendirme parantezi kullanılır. Örneğin:
		  	x = (y + z) * t
		 işleminin yapılış sırası şöyledir:
		 	i1: y + z
		 	i2: i1 * t
		 	i3: x = i2
		 Bazı operatörler aynı öncelik seviyesinde olabilirler. Bu durumda aynı öncelik seviyesine sahip operatörlerin
		 aynı ifadede bulunması durumunda işlemin hangi sırada yapılacağını belirleyen "associativity" denilen bir kavram
		 kullanılır. Bu anlamda "left associative" ve "right associative" kavramları sırasıyla "soldan sağa öncelik" ve 
		 "sağdan sola öncelik" anlamına gelir. Örneğin:
		 	x = y + z - t
		 işleminin yapılış sırası + ve - operatörleri aynı öncelik seviyesinde ve left associative olduklarından şöyledir:
		 	i1: y + z
		 	i2: i1 - t
		 	i3: x = i2
		 
		Anahtar Notlar: Java'da öncelik kavramı, her zaman işlem sırasını da belirlemez. Bu durumun detayları konu içerisinde
		ele alınacaktır.

	Biz de bir operatörü öğrenirken o operatör için bu özellikleri inceleyeceğiz
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aritmetik 4 işlem operatörleri (+, -, *, /) iki operandlı ve araek durumundadır. Operatörler işlemin sonucuna ilişkin
	değeri üretirler. Bu operatörlerin yan etkisi yoktur. * ve / operatörleri, + ve - operatörlerinden yüksek önceliklidir.
	Aritmetik 4 işlem operatörleri soldan sağa önceliklidir. İlgili operatöre ilişkin geçerli işlemler kısıt olarak
	düşünülebilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		System.out.printf("%d + %d = %d%n", a, b, a + b);
		System.out.printf("%d - %d = %d%n", a, b, a - b);
		System.out.printf("%d * %d = %d%n", a, b, a * b);
		System.out.printf("%d / %d = %d%n", a, b, a / b);	
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Mod operatörü (%) aslında bir çeşit bölme işlemi yapar. Bu sebeple öellikler ürettiği değer dışında bölme operatörü
	ile aynıduır. Bu operatör birinci operandının ikinci operandına bölümünden elde edilen kalan değerini verir. Bu 
	operatörün ikinci operandının işaretinin önemi yoktur. Yani ikinci operandı negatif bile olsa pozitif değeri ile
	işlem yapılır. Bu operatörün birinci operandı negatif ise işlem şu şekilde yapılır: Birinci operandın pozitif oldığu
	değere göre kalan değerinin ters işaretlisi alınır. Yani bu operaörün ürettiği değerin işareti birinci operandının
	işareti ile aynıdır. Yani sonuç olarak bu operatör negatif operandlar için Matematik'teki mod alma işlemi ile aynı 
	değildir. Bazı programlama dillerinde gerçek sayılar için mod operatörü kullanılamaz. Ancak Java'da böyle bir 
	kısıt yoktur. Pratikte bu operatörler daha daha çok tamsayılarla kullanılır. Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		System.out.printf("%d %% %d = %d%n", a, b, a % b);	
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden 3 basamaklı bir sayının basamakları toplamına geri dönen 
	sumOf3Digits metodunu NumberUtil isimli sınıf içerisinde aşağıdaki açıklamalara göre yazınız ve test ediniz.
	Açıklamalar:
		- Metot sayının 3 basamaklı olup olmadığı kontrolünü yapmayacaktır
		- Metot negatif sayılar için de pozitif toplam değerine geri dönecektir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		NumberUtilSumOf3DigitsTest.run();	
	}
}

class NumberUtilSumOf3DigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		System.out.printf("%d sayısının basamakları toplamı:%d%n", a, NumberUtil.sumOf3Digits(a));
	}
}

class NumberUtil {
	public static int sumOf3Digits(int val)
	{
		int a = val / 100;
		int b = val / 10 % 10;
		int c = val % 10; 
		
		return Math.abs(a + b + c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden 3 basamaklı bir sayının basamakları toplamına geri dönen 
	sumOf3Digits metodunu NumberUtil isimli sınıf içerisinde aşağıdaki açıklamalara göre yazınız ve test ediniz.
	Açıklamalar:
		- Metot sayının 3 basamaklı olup olmadığı kontrolünü yapmayacaktır
		- Metot negatif sayılar için de pozitif toplam değerine geri dönecektir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		NumberUtilSumOf3DigitsTest.run();	
	}
}

class NumberUtilSumOf3DigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		System.out.printf("%d sayısının basamakları toplamı:%d%n", a, NumberUtil.sumOf3Digits(a));
	}
}

class NumberUtil {
	public static int sumOf3Digits(int val)
	{
		int a = val / 100;
		int b = val % 100 / 10;
		int c = val % 10; 
		
		return Math.abs(a + b + c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İşaret - aritmetik operatörü tek operandlı ve önek durumundadır. Bu operatör operandına ilişkin ifadenin ters 
	işeretlisini üretir. Operatörün yan etkisi yoktur. Operatör ikinci seviyede ve dolayısıyla sağdan sola önceliklidir.
	Operatör eksi işareti alınabilen her tür için kullanılabilir. İşaret + operatörü yine aynı özelliklere sahip 
	ancak ifadenin değerini üreten bir operatördür. Bu anlamda + operatörü kullanmakla kullanmamak arasında fark yoktur.
	Bütünlük açısında dile eklenmiştir. Aşağıdaki demo örneği inceleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int x;
		
		x = -a;
		
		System.out.printf("x = %d%n", x);
		
		x = +a;
		
		System.out.printf("x = %d%n", x);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Okunabilirlik/algılanabilirlik açısından özel bazı operatörler dışında iki operandlı (binary)
	operatörlerin operandları ile aralarından bir tane space karakteri bulundurulur. Örneğin a + b işleminde operandlar
	ile operatör arasında birer boşluk yazılır. Ancak nokta operatörü için özellikle bitişik yazılması önerilir. Tek
	operandlı operatörler için de operatörün operandına bitişik olarak yazılması tavsiye edilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	++/-- operaörü tek operandlı hem önek hem de sonek kullanılabilen bir aritmetik operatördür. Operatörün operandının
	bir değişken olması zorunludur. Yani sabit ifadesi olamaz. Operatörün ürettiği değer önek ve son ek kullanıma
	göre değişiklik gösterir. Operatörün yan etkisi vardır, operandı olan değişkenin değerini bir artırır/azaltır.
	Operatör önek kullanımda artırılmış/azaltılmış değeri, sonek kullanımda ise artırılmamış/azaltılmamış değeri üretir.
	Yani işleme giren değer önek ve sonek durumunda farklıdır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	++ operatörü
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		
		++a; //a = a + 1;
		
		System.out.printf("a = %d%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	++ operatörü
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		
		a++; //a = a + 1;
		
		System.out.printf("a = %d%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	++ operatörünün önek kullanımı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		int b;
		
		b = ++a;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	++ operatörünün sonek kullanımı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		int b;
		
		b = a++;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	++ operatörü
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		
		++a; //a = a + 1;
		
		System.out.printf("a = %d%n", a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	-- operatörü
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		
		a--; //a = a - 1;
		
		System.out.printf("a = %d%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	++ operatörünün önek kullanımı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		int b;
		
		b = --a;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	++ operatörünün sonek kullanımı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		int b;
		
		b = a--;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		int b;
		
		b = a-- + a;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		int b;
		
		b = a + a--;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		int b;
		
		b = a++ + a--;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 2;
		int b;
		
		b = a++ + a * --a; // 2 + 3 * 2
		
		System.out.printf("a = %d, b = %d%n", a, b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java derleyicisi soldan sağa ve yukarıdan aşağıya anlamlı en uzun ifadeyi alacak şekilde atomalarına ayırma (tokenizing)
	işlemini yapar. Bu kurala genel olarak "maximal/maximum munch" kuralı denir. Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 3;
		int b = 4;
		int c;
		
		c = a+++b; //a++ + b
		
		System.out.printf("a = %d%n", a); //a = 4
		System.out.printf("b = %d%n", b); //b = 4
		System.out.printf("c = %d%n", c); //c = 7
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	12 Mart 2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte maximal munch kuralı gereği error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 3;
		int b = 4;
		int c;
		
		c = a++++b; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 3;
		int b = 4;
		int c;
		
		c = a+++-b; // c = a++ + -b;
		
		System.out.printf("a = %d%n", a); //a = 4
		System.out.printf("b = %d%n", b); //b = 4
		System.out.printf("c = %d%n", c); //c = -1
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte maximal munch kuralı gereği error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 3;
		int b = 4;
		int c;
		
		c = a+++++b; // error
		
		System.out.printf("a = %d%n", a); //a = 4
		System.out.printf("b = %d%n", b); //b = 4
		System.out.printf("c = %d%n", c); //c = -1
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 3;
		int b = 4;
		int c;
		
		c = a+++ + +b;
		
		System.out.printf("a = %d%n", a); //a = 4
		System.out.printf("b = %d%n", b); //b = 4
		System.out.printf("c = %d%n", c); //c = 7
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a;
		
		a = - - - - - - - - - - - - - - - - - - - 2;
		
		System.out.printf("a = %d%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Temel karşılaştırma operatörleri 6 tanedir: <, > , <=, >=, ==, !=
	
	Bu operatörler iki operandlı, araek durumundadır. Operatörlerin yan etkisi yoktur. Bu operatörlerin ürettiği değer
	boolean türdendir. Karşılaştırma işlemi doğru ise true, yanlış ise false değerini üretir. <, >, <=, >= operatörleri
	klasik operatörlerdir. == operatörü operandlarına ilişkin ifadelerin değerleri eşitse true, değilse false değerini
	üretir. != operatörü operandlarına ilişkin ifadelerin değerleri eşit değilse true, eşitse false değerini üretir. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		System.out.printf("%d < %d = %b%n", a, b, a < b);
		System.out.printf("%d >= %d = %b%n", a, b, a >= b);
		System.out.printf("%d > %d = %b%n", a, b, a > b);
		System.out.printf("%d <= %d = %b%n", a, b, a <= b);
		System.out.printf("%d == %d = %b%n", a, b, a == b);
		System.out.printf("%d != %d = %b%n", a, b, a != b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java'da metot çağırma işlemi metot çağırma operatörü (method call operator) ile yapılır. Bu operatör özel amaçlı
	iki veya tek operandlıve araek durumunda bir operatördür. Operatör, operatör öncelik tablosunun birinci seviyesindedir.
	Operatör ilgili metodu çağırır ve eğer metodun geri dönüş değeri varsa geri dönüş değerini üretir. Geri dönüş değeri
	olmayan bir metot çağrısı için bu operatöre ilişkin ifadenin türü void'dur. Bu anlamda void aslında bir tür olmamasına
	rağmen, dilin Matematiksel bütünlüğü adına bir tür gibi kullanılabilmektedir. Bu anlamda bir değer üretmeyebilen
	tek operatör metot çağırma operatörüdür. Eğer, void bir metot çağrılırsa bu operatör değer üretmez  
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Mantıksal operatörler şunlardır: AND (&&), OR (||), NOT (!).
	Bu operatörler Mantık'taki ilgili operatörleri temsil eder. Bu operatörlerin operandları boolean türden olmalıdır.
	Aksi durumda error oluşur. Operatörlerin ürettiği değer de boolean türdendir. Bu operatörlerin yan etkileri yoktur.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anımsanacağı gibi && ve || operatörlerinin doğruluk tablolaları (truth table) şu şekildedir:
	
	a		b		&&		||
	---------------------------
	T		T		T		T
	T		F		F		T
	F		T		F		T
	F		F		F		F
	
	Bu doğruluk tablosundan kısaca şu sonuçlar çıkartılabilir:
	- && işlemi için: Her ikisi birden doğru ise doğru sonuç verir. Ya da başka bir deyişle en az biri yanlışsa yanlış
	sonuç verir.
	
	- || işlemi için: Her ikisi yanlış ise yanlış sonuç verir. Ya da başka bir deyişle en az biri doğruysa doğru
	sonuç verir. 
	
	Bu operatörler doğru sonuca yani Matematiksel olarak elde edilen sonuca en kısa yoldan ulaşmaya çalışırlar. Bu 
	sebeple bu operatörlerin bulunduğu ifadeler hesaplanmaya en soldan başlar. && ve || operatörlerinde birinci 
	operand hesaplandığında elde edilen sonuç, ikinci operand hesaplansa da değişmeyecekse ikinci operand hesaplanmaz.
	Buna kısa devra davranışı (short circuit behavior) denir. Bu durumda && operatörü için birinci operanda ilişkin
	ifadenin değeri false ise ikinci operanda ilişkin ifade yapılmaz, || operatörü için birinci operanda ilişkin
	ifadenin değeri true ise ikinci operanda ilişkin ifade yapılmaz.    
	
	Bu operatörler yine doğru sonuca en kısa yoldan ulaşmak için klasik operatör önceliği kuralına işlemi yaparken 
	uymazlar. Yani bu operatörlere ilişkin bir ifade, öncelik ne olursa olsun en soldan başlanarak hesaplanır. Ancak 
	elde edilen sonuç operatör önceliğine uyularak yapılan işlem sırası ile elde edilen sonuç ile aynıdır.  Yani bu 
	operatörler yine  kısa devre davranışını da kullanarak doğru sonuca en kısa yoldan ulaşırlar
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	&& operatörüne ilişkin demo örneği inceleyiniz:
	Ekran Çıktısı:
	foo
	bar
	false
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		boolean result;
		
		result = Sample.foo() && Sample.bar();
		
		System.out.printf("result:%b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	|| operatörüne ilişkin demo örneği inceleyiniz
	Ekran Çıktısı:
	bar
	foo
	true
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		boolean result;
		
		result = Sample.bar() || Sample.foo();
		
		System.out.printf("result:%b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağdaki demo örnekte kısa devre oluşur
	Ekran Çıktısı:
	foo
	true
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		boolean result;
		
		result = Sample.foo() || Sample.bar();
		
		System.out.printf("result:%b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağdaki demo örnekte kısa devre oluşur
	Ekran Çıktısı:
	bar
	false
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		boolean result;
		
		result = Sample.bar() && Sample.foo();
		
		System.out.printf("result:%b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağdaki demo örneği inceleyiniz
	Ekran Çıktısı:
	foo	
	true
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		boolean result;
		
		result = Sample.foo() || Sample.bar() && Sample.tar();
		
		System.out.printf("result:%b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
	
	public static boolean tar()
	{
		System.out.println("tar");
		
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağdaki demo örneği inceleyiniz
	Ekran Çıktısı:
	bar
	tar
	false
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		boolean result;
		
		result = Sample.bar() && Sample.foo() || Sample.tar();
		
		System.out.printf("result:%b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
	
	public static boolean tar()
	{
		System.out.println("tar");
		
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağdaki demo örnekte || operatörüne öncelik verilmiştir
	Ekran Çıktısı:
	foo
	tar
	false
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		boolean result;
		
		result = (Sample.foo() || Sample.bar()) && Sample.tar();
		
		System.out.printf("result:%b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
	
	public static boolean tar()
	{
		System.out.println("tar");
		
		return false;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağdaki demo örnekte önceliklendirme parantezinin olması ile olmamsı arasında bir fark yoktur
	Ekran Çıktısı:
	foo
	true
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		boolean result;
		
		result = Sample.foo() || (Sample.bar() && Sample.tar());
		
		System.out.printf("result:%b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
	
	public static boolean tar()
	{
		System.out.println("tar");
		
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		boolean result;
		
		result = Sample.bar() || Sample.foo() && Sample.tar() || Sample.foo() && Sample.bar();
		
		System.out.printf("result:%b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
	
	public static boolean tar()
	{
		System.out.println("tar");
		
		return false;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	14 Mart 2024
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Bitwise AND (&) ve bitwise OR (|) operatörleri tamsayılar ile bitsel işlemler yaparlar. Bu operatörler özel olarak
	boolean türü ile kullanıldıklarında (yani operandları boolen türden olduğunda) kısa devre davranışı olmayan AND
	ve OR işlemleri olarak düşünülmeldir. Yani bu operatörler boolean türü ile kullanıldıklarında, işlem sırası yine 
	&& ve || operatörleri ile aynıdır ancak kısa devre davranışı olmaz.
	
	Anahtar Notlar: Java'da tamsayılar ile bitsel işlemler yapan bir grup operatör vardır. Bunlara "bitwise operators"
	denilmektedir. Bitsel operatörlerin detayları ve kullanım alanları "Java ile Uygulama Geliştirme 1" ve "Android Programlama"
	kurslarında ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte tüm metotların çağrıldığına dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		boolean result;
		
		result = Sample.foo() | Sample.bar() & Sample.tar();
		
		System.out.printf("result:%b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
	
	public static boolean tar()
	{
		System.out.println("tar");
		
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10; //0b00000000000000000000000000001010 <-> 0x0000000A
		int b = 11; //0b00000000000000000000000000001011 <-> 0x0000000B
		int c;
		
		c = a & b;
		
		System.out.printf("a = %d, a = %08X%n", a, a);
		System.out.printf("b = %d, b = %08X%n", b, b);		
		System.out.printf("c = %d, c = %08X%n", c, c);
		System.out.println("-----------------------------------");
		
		c = a | b;
		
		System.out.printf("a = %d, a = %08X%n", a, a);
		System.out.printf("b = %d, b = %08X%n", b, b);		
		System.out.printf("c = %d, c = %08X%n", c, c);
		System.out.println("-----------------------------------");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Logical NOT (!) operatörü tek operandlı ve önek durumundadır. Operatörün yan etkisi yoktur. Logical NOT işleminin
	doğruluk tablosu şu şekildedir:
	a 			!a
	-----------------
	T			F
	F			T
	
	Bu operatör operandına ilişkin ifadenin mantıksal değilini (yani ifade true ise false, ifade false ise true değerini) 
	üretir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		boolean flag = false;
		
		flag = !flag;
		
		System.out.printf("flag = %b%n", flag);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Atama operatörü (assignment operator) özel amaçlı, iki operandlı ve araek durumundadır. Operatörün birinci operandı
	bir değişken olmalıdır. Operatörün yan etkisi vardır. Operatör sağdan sola önceliklidir (right associative). Operatörün 
	ürettiği değer atanan değerdir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a, b, c;
		
		a = b = c = 10;
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte ikinci atama operatörünün birinci operandı değişken olmadığından error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a, b = 20, c;
		
		(a = b) = c = 10; //error
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte üçüncü atama operatörünün birinci operandı değişken olmadığından error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a, b = 20, c;
		
		a = (b = c) = 10;
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnek geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a, b, c;
		
		a = b = (c = 10);
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnek geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a, b, c;
		
		a = (b = c = 10);
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java'da bir grup işlemli atama operatörü (compound/augmented assignment operators) vardır. Bu operatörler iki
	operandlı ve araek durumundadır.Bu operatörlerin genel biçimi şu şekildedir:
	
		<ifade1> <op>= <ifade2>
		
	işleminin yaklaşık karşılığı
	
		<ifade1> = <ifade1> <op> <ifade2>
		
	biçimindedir. Burada ifade1'in değişken olması zorunludur. Bu operatör kullanılabildiği durumlarda kesinlikle
	açık işlemine göre tercih edilmeldir. Örneğin programcı
	 
		x = x + 2;
		
	ifadesi yerine
	
		x += 2;
		
	yazmalıdır. Operatörlerin ürettiği değer yine atanan değerdir. Aslında bu operatörler hem okunabililiği/algılanabilirliği 
	artırır hem de ifadelerin daha basit (yalın) olarak yazılabilmesi sağlar.
	
	Anahtar Notlar: Aslında işlemli atama operatörlerinin genel biçimi tam olarak yukarıda anlatıldığı gibi değildir.
	İleride tam karşılığı ele alınacaktır. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		int b = 20;
		
		a += b;
		
		System.out.printf("a = %d, b = %d%n", a, b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 2;
		int b = 3;
		
		a *= b + 2; //a = a * (b + 2);
		
		System.out.printf("a = %d, b = %d%n", a, b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Noktalı virgül Java'da sonlandırıcı (terminator) karakter olarak kullanılır. Java'da başka terminator karakter yoktur.
	Noktalı virgül genel olarak ifadeleri sonlandırmak ve bazı deyimleri de sonlandırmak için kullanılır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java'da etkisiz ifadeler genel olarak geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 10;
		int b = 20;
		
		a + b; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Derleyici akışın hiç bir zaman o noktaya gelemeyeceği kodlar için genel olarak error oluşturur (unreachable code)
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static int add(int a, int b)
	{
		return a + b;
		
		System.out.println("Unreachable code"); //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağdaki demo örneği inceleyiniz
	a = a++;
	i1: a++
	i2: a = i1
	Not: Hiç güzel bir örnek değildir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 2;
		
		a = a++;
		
		System.out.printf("a = %d%n", a); //a = 2
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağdaki demo örneği inceleyiniz
	a = ++a;
	i1: ++a
	i2: a = i1
	Not: Hiç güzel bir örnek değildir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		int a = 2;
		
		a = ++a;
		
		System.out.printf("a = %d%n", a); //a = 2
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	19 Mart 2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Deyimler (Statements): Programın çalıştırılan parçalarına denir. Bir program deyimlerin çalıştırılmasıyla çalışır. 
	Java'da deyimler şunlardır:
	- Basit deyimler (simple statements): Bir ifadenin sonuna noktalı virgül konmasıyla oluşan deyimdir. Örneğin:
		System.out.println("Merhaba"); ya da x = y + z;
	Basit bir deyim çalıştırıldığında deyime ilişkin ifade hesaplanır.
	  
	- Bileşik deyimler (compound statements): { ve } arasında kalan yani bir blok içerisinde yazılan deyimlerdir. 
	Bileşik deyim çalıştırıldığında blok içerisindeki deyimler yukarıdan aşağıya çalıştırılır.  Bu anlamda metodun
	gövdesi de aslında bileşik olarak düşünülebilir.
	
	- Bildirim deyimleri (declaration statements): Bir değişkenin bildirildiği deyimdir. Bildirim deyimi çalıştırıldığında
	bellekte yer ayrılır. Örneğin:
		int a; ya da int x = 20;
	
	- Kontrol deyimleri (control statements): Akışa yön veren deyimlerdir. Her kontrol deyiminin kendine özgü çalıştırılma
	biçimi vardır. Java'da önemli bazı kontrol deyimleri şunlardır:
		- return deyimi
		- if deyimi
		- döngü deyimleri (for, while, do-while), for-each)
		- break deyimi
		- continue deyimi
		- switch deyimi/ifadesi
	
	- Boş deyim (null/empty statement): Noktalı virgülün tek başına kullanılması durumunda oluşan deyimdir. Boş deyim
	çalıştırıldığında hiç bir şey yapılmaz.	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	if deyimi: Neredeyse tüm programlama dillerinde bulunan ve koşula bağlı olarak akışın yönlemesini sağlayan bir 
	kontrol deyimidir. if deyiminin genel biçimi şu şekildedir:
	
		if (<koşul ifadesi>)
			<deyim>
		[
		else 
			<deyim>
		]
		
	if deyiminde koşul ifadesinin (condition expression) boolean türden olması zorunludur. Aksi durumda error oluşur.
	if deyiminde koşul ifadesinin değeri true ise if deyiminin doğru kısmına ilişkin deyim çalıştırılır, false ise
	if deyiminde else kısmı varsa else kısmına ilişkin (yani yanlış kısmına ilişkin deyim) çalıştırılır. Bu anlamda if
	deyiminin else kısmı olmak zorunda değildir. if deyiminin else kısmı yoksa ve koşul ifadesinin değeri false ise,
	akış if deyiminden sonraki deyimden devbam eder. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		
		if (a % 2 == 0)
			a /= 2;
		else
			a *= 2;
		
		System.out.printf("a = %d%n", a);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte if deyiminin doğru kısmında ve else kısmında bileşik deyim kullanılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		
		if (a % 2 == 0) {
			System.out.println("Çift sayı girdiniz");
			a /= 2;
		}
		else {
			System.out.println("Tek sayı girdiniz");
			a *= 2;
		}
		
		System.out.printf("a = %d%n", a);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: if deyiminde (ve döngü deyimlerinde) basit deyimin kullanılabildiği yerde bazı programcılar yine
	bileşik deyim kullanmayı tercih ederler. Diğer bir deyişle hiç bir zaman basit deyim kullanmazlar. Bazı programcılar
	ise basit deyimininn kullanılabildiği yerlerde bileşik deyim kullanmazlar. Bu yaklaşımların her ikisi de normal ve
	doğru yaklaşımlardır. Bir programcı yada bir yazılım geliştirme ekibi bu yaklaşımlardan herhangi birisini tercih 
	edebilir. Ancak bu tip durumlarda kötü yaklaşım bazen birini, bazen diğerini kullanmaktır. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte if deyiminin else kısmı yoktur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		
		if (a % 2 == 0)
			a /= 2;
		
		System.out.printf("a = %d%n", a);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte if deyiminde yanlışlıkla noktalı virgül konmasından dolayı ** ile belirtilen deyim if deyiminden
	sonraki deyim olduğundan error oluşmaz. Burada derleyici açısında if deyiminin doğru kısmında boş deyim kullanılmıştır.
	O da herhangi bir error'a yol açmaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		
		if (a % 2 == 0);
			a /= 2; //**
		
		System.out.printf("a = %d%n", a);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte else'in ait olduğu bir if deyimi olmadığından error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a % 2 == 0);
			a /= 2;
		else //error
			a *= 2;
		
		System.out.printf("a = %d%n", a);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte * ile belirtilen if deyiminin else kısmında bir if deyimi vardır.
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a > 0) //*
			System.out.printf("Pozitif sayı girdiniz:%d%n", a);
		else 
			if (a == 0)
				System.out.println("Sıfır giriniz");
			else
				System.out.printf("Negatif sayı girdiniz:%d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki demo örnek aşağıdaki gibi daha okunabilir şekilde yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a > 0)
			System.out.printf("Pozitif sayı girdiniz:%d%n", a);
		else if (a == 0)
			System.out.println("Sıfır giriniz");
		else
			System.out.printf("Negatif sayı girdiniz:%d%n", a);
	
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek aşağıdaki gibi yazılsaydı, örneğin senaryosu gereği doğru çalışacaktı. Ancak, koşullar ayrık (discrete)
	olduğundan else biçiminde yazılması hem gereksiz kontrolleri engeller, hem de daha okunabilir/algılanabilir yazılmış
	olur. Aşağıdaki kodu okuyan programcı koşulların ayrık olmadığını izlenimine kapılır. Bu durumda aslında ayrık
	koşullar iin else if kullanmak ayrık olmayan koşullara ilişkin if deyimlerinin okunabilirliğini/algılanabilirliğini
	artırır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a > 0)
			System.out.printf("Pozitif sayı girdiniz:%d%n", a);
		if (a == 0)
			System.out.println("Sıfır giriniz");
		if (a < 0)
			System.out.printf("Negatif sayı girdiniz:%d%n", a);
	
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte koşullar ayrık olmadığından, ayrı if deyimleri yazılması uygundur 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a > 6)
			System.out.printf("%d > 6%n", a);
		if (a > 10)
			System.out.printf("%d > 10%n", a);
		if (a > 22)
			System.out.printf("%d > 22%n", a);
	
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	boolean türden ifadelerin değerlerinin koşul ifadesinde karşılaştırılmasının == veya != operatörleri ile yapılması
	tevsiye edilmez
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		Util.printValueStatus(a % 2 == 0);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class Util {
	public static void printValueStatus(boolean status)
	{
		if (status) //if (status == true) 
			System.out.println("Çift");
		else
			System.out.println("Tek");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	boolean türden ifadelerin değerlerinin koşul ifadesinde karşılaştırılmasının == veya != operatörleri ile yapılması
	tevsiye edilmez
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		Util.printValueStatus(a % 2 == 0);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class Util {
	public static void printValueStatus(boolean status)
	{
		if (!status) //if (status == false) 
			System.out.println("Tek");
		else
			System.out.println("Çift");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Pratikte geri dönüş değeri boolean olan metotlarla çok fazla karşılaşırız. Bu metotlar tipik olarak bir işlemin
	sonucuna ilişkin doğruluğu veya yanlışlığı test etmek için kullanılır. Örneğin, bir kişinin bilgilerine göre 
	kişinin evli olup olmadığını test etmek için kullanılan bir metot tipik olarak boolean türden geri dönüş değere
	sahip olacak şekilde yazılır. Ya da örneğin bir dosyanın belirtilen yol ifadesine ilişkin yerde olup olmadığını 
	test eden bir metot yine boolean türden geri dönüş değere sahip olacak şekilde yazılır. Bu tarz metotlara pratikte
	"predicate methods" da denilmektedir. Predicate bir metot, eğer bir isme ilişkinse genelliklen is (bazen has, can vb)
	ile başlatılır. Örneğin bir kişinin evli olup olmadığını test eden bir metodun ismi isMarried olarak seçilebilir. 
	Predicate bir metot bir fiile ilişkinse bu durumda İngilizce özneye göre belirlenir. Örneğin yol ifadesindeki
	dosyanın varlığını test eden metodun ismi exists olarak seçilebilir. 
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
 	Aşağıdaki isEven metodunda akış return true deyimine geldiğinde zaten sonlanacağından else anahtar sözcüğünün 
 	yazılmasıyla yazılmaması arasında bir fark yoktur. Böylesi durumlarda else yazılmaması önerilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (NumberUtil.isEven(a))
			System.out.printf("Çift sayı:%d%n", a);
		else
			System.out.printf("Tek sayı:%d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class NumberUtil {
	public static boolean isEven(int a)
	{
		if (a % 2 == 0)
			return true;
		else 
			return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
 	Yukarıdaki metot aşağıdaki gibi daha okunabilir/algılanabilir olarak yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (NumberUtil.isEven(a))
			System.out.printf("Çift sayı:%d%n", a);
		else
			System.out.printf("Tek sayı:%d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class NumberUtil {
	public static boolean isEven(int a)
	{
		if (a % 2 == 0)
			return true;
		
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
 	Yukarıdaki metot en okunabilir/algılanabilir olarak aşağıdaki gibi yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (NumberUtil.isEven(a))
			System.out.printf("Çift sayı:%d%n", a);
		else
			System.out.printf("Tek sayı:%d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class NumberUtil {
	public static boolean isEven(int a)
	{
		return a % 2 == 0;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	21 Mart 2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
 	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (!NumberUtil.isEven(a))
			a *= 2;
		
		System.out.printf("a = %d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class NumberUtil {
	public static boolean isEven(int a)
	{
		return a % 2 == 0;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
 	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (NumberUtil.isOdd(a))
			a *= 2;
		
		System.out.printf("a = %d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class NumberUtil {
	public static boolean isEven(int a)
	{
		return a % 2 == 0;
	}
	
	public static boolean isOdd(int a)
	{
		return !isEven(a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
 	Aşağıdaki demo örnekte else içteki if deyimine ait olur. Buna "dangling else" denir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a > 0)
			if (a % 2 == 0)
				System.out.println("Çift sayı girdiniz");			
		else
			System.out.println("Negatif sayı girdiniz");	
				
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
 	Yukarıdaki dangling else durumu bileşik deyim kullanılarak da çözülebilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a > 0)  {
			if (a % 2 == 0)
				System.out.println("Çift sayı girdiniz");
		}
		else
			System.out.println("Negatif sayı girdiniz");
				
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
 	Aşağıdaki demo örnekte dangling else durumu yoktur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a > 0) 
			if (a % 2 == 0)
				System.out.println("Çift sayı girdiniz");		
			else 
				System.out.println("Tek sayı girdiniz");
		else
			System.out.println("Negatif sayı girdiniz");		
				
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
 	Sınıf Çalışması: Katsayıları klavyeden girilen ikinci dereceden denklemin köklerini bulan ve ekrana basan programı
 	yazınız
 	Not: Örnek şu ana gördüklerimiz kullanılarak, daha genel yazılmaya çalışılmıtır. İleride daha iyisi yazılacaktır
 	Not: Formül için ~/doc/images/ikinci-dereceden-denklem.jpg dosyasından yararlanabilirsiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		QuadraticEquationSolverApp.run();
	}
}

class QuadraticEquationSolverApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Input coefficients:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		double c = kb.nextDouble();
		
		EquationSolver.findQuadraticRoots(a, b, c);
	}
}

class EquationSolver {
	public static double calculateDelta(double a, double b, double c)
	{
		return b * b - 4 * a * c;
	}
	
	public static void doForDoubleRoots(double delta, double a, double b)
	{
		double sqrtDelta = Math.sqrt(delta);
		double x1, x2;
		
		x1 = (-b + sqrtDelta) / (2 * a);
		x2 = (-b - sqrtDelta) / (2 * a);
		
		System.out.printf("x1 = %f, x2 = %f%n", x1, x2);		
	}
	
	public static void doForSameRoot(double a, double b)
	{
		double x = -b / (2 * a);
		
		System.out.printf("x1 = x2 = %f%n", x);
	}
	
	public static void findQuadraticRoots(double a, double b, double c)
	{
		double delta = calculateDelta(a, b, c);
		
		if (delta > 0)
			doForDoubleRoots(delta, a, b);
		else if (delta == 0)
			doForSameRoot(a, b);
		else
			System.out.println("No real root!...");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
 	Sınıf Çalışması: Katsayıları klavyeden girilen ikinci dereceden denklemin köklerini bulan ve ekrana basan programı
 	yazınız
 	Not: Örnek şu ana gördüklerimiz kullanılarak, daha genel yazılmaya çalışılmıtır. İleride daha iyisi yazılacaktır
 	Not: Formül için ~/doc/images/ikinci-dereceden-denklem.jpg dosyasından yararlanabilirsiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		QuadraticEquationSolverApp.run();
	}
}

class QuadraticEquationSolverApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Input coefficients:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		double c = kb.nextDouble();
		
		EquationSolver.findQuadraticRoots(a, b, c);
	}
}

class EquationSolver {
	public static double calculateDelta(double a, double b, double c)
	{
		return b * b - 4 * a * c;
	}
	
	public static void doForRoots(double delta, double a, double b)
	{
		double sqrtDelta = Math.sqrt(delta);
		double x1, x2;
		
		x1 = (-b + sqrtDelta) / (2 * a);
		x2 = (-b - sqrtDelta) / (2 * a);
		
		System.out.printf("x1 = %f, x2 = %f%n", x1, x2);		
	}

	
	public static void findQuadraticRoots(double a, double b, double c)
	{
		double delta = calculateDelta(a, b, c);
		
		if (delta >= 0)
			doForRoots(delta, a, b);
		else
			System.out.println("No real root!...");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
 	Döngü Deyimleri: Bir işin yinelemeli (iterative) bir biçimde yapılmasını sağlayan kontrol deyimlerinde döngü deyimleri
 	(loop statements) denir. Java'da döngü deyimleri genel olarak 3 gruba ayrılır:
	 	1. while döngü deyimi
	 		- Kontrolün başta yapıldığı while döngü deyimi (while döngüsü)
	 		- Kontrolün sonda yapıldığı while döngü deyimi (do-while döngüsü)
	 	2. for döngü deyimi
	 	3. for-each (enhanced for loop) döngü deyimi
	 	
	 Anahtar Notlar: while döngüsü dendiğinde genel olarak "kontrolün başta yapıldığı while döngü deyimi" anlaşılır. Burada da
	 while döngüsü dendiğinde bu şekilde anlaşılmalıdır. "Kontrolün sonda yapıldığı while döngü deyimi" için "do-while döngüsü"
	 terimi kullanılacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
 	Kontrolün başta yapıldığı while döngü deyiminin (while döngüsü) genel biçimi şu şekildedir:
 	
 		while (<boolean türden ifade>)
 			<deyim>
 			
 	while döngüsü koşul ifadesi doğru sürece yinelenen döngü deyimidir. Akış while döngü deyimine geldiğinde de koşul
 	kontrol edilir, eğer yanlış ise döngüye girilmez. Koşul ifadesinin boolean türden olmamasın durumunda error oluşur
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
 	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i;
		
		i = 0;
		
		while (i < n) {
			System.out.printf("%d ", i);
			++i;
		}
		
		System.out.printf("%nDöngü sonrası i = %d%n", i);
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
 	while döngü deyiminde yanlışlıkla noktalı virgül kullanılması (yani yanlışlıkla boş deyim kullanılması) durumu
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i;
		
		i = 0;
		
		while (i < n); {
			System.out.printf("%d ", i);
			++i;
		}
		
		System.out.printf("%nDöngü sonrası i = %d%n", i);
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
 	while döngü deyimi ile n-kez dönen döngü deyimi de oluşturulabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i;
		
		i = 0;
		
		while (i < n) {
			System.out.printf("%d ", i);
			++i;
		}
		
		System.out.printf("%nDöngü sonrası i = %d%n", i);
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
 	while döngü deyimi ile n-kez dönen döngü deyimi de oluşturulabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i;
		
		i = n - 1;
		
		while (i >= 0) {
			System.out.printf("%d ", i);
			--i;
		}
		
		System.out.printf("%nDöngü sonrası i = %d%n", i);
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
 	Aşağıdaki döngü deyimi bazı programcılar tarafından kullanılan "n-kez dönen" döngü kalıbıdır. Bu kalıbı programcı
 	kullanmak istemese de gördüğünde tanımalıdır. Bu döngü deyiminde n değerinin, döngüden sonra artık eski değerinde 
 	olmadığına dikkat ediniz. Örneği çeşitli değerlerle çalıştırıp sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
	
		while (n-- > 0)
			System.out.printf("%d ", n);
		
		System.out.println();		
		System.out.printf("Döngü sonrası n:%d%n", n);
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
 	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısını döndüren countDigits metodunu 
 	NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		NumberUtilCountDigitsTest.run();
	}
}

class NumberUtilCountDigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();
		
		System.out.printf("%d sayısının basamak sayısı:%d%n", val, NumberUtil.countDigits(val));
	}
}

class NumberUtil {
	public static int countDigits(int val)
	{
		if (val == 0)
			return 1;
		
		int count = 0;
		
		while (val != 0) {
			++count;
			val /= 10;			
		}
		
		return count;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	26 Mart 2024
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
 	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamakları toplamına geri dönen sumDigits isimli
 	metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
 	Açıklama: Sayı negatif ise basamakları toplamı pozitif olarak elde edilecektir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		NumberUtilSumDigitsTest.run();
	}
}

class NumberUtilSumDigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();
		
		System.out.printf("%d sayısının basamakları toplamı:%d%n", val, NumberUtil.sumDigits(val));		
	}
}

class NumberUtil {
	public static int sumDigits(int val)
	{
		int total = 0;
		
		while (val != 0) {
			total += val % 10;
			val /= 10;
		}
		
		return Math.abs(total);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
 	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının tersine geri dönen reverse isimli metodu NumberUtil
 	sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
 	Örnek: 
 	123	-> 3 * 10 + 2 = 32 -> 32 * 10 + 1 = 321
 	-123 -> -3 * 10 - 2 = -32 -> -32 * 10 - 1 = -321
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		NumberUtilReversedTest.run();
	}
}

class NumberUtilReversedTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();
		
		System.out.printf("%d sayısının tersi:%d%n", val, NumberUtil.reverse(val));		
	}
}

class NumberUtil {
	public static int reverse(int val)
	{
		int result = 0;
		
		while (val != 0) {
			result = result * 10 + val % 10;
			val /= 10;
		}
		
		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
 	while döngüsünün koşul ifadesinde bir değişkene bir metodun geri dönüş değeri atanıp, atanan değer kontrol edilebilir.
 	Bu tarz koşul ifadeleri okunabilirliği/algılanabilirliği olumsuz etkilemedikten sonra yazılabilir. Aşağıdaki örnekte
 	klavyeden sıfır girilene kadar alınan sayıların toplamı bulunmuştur. Örnekte atama işleminin önceliklendirildiğine
 	dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Sayıları girmeye başlayınız:");
		int total = 0;		
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0)
			total += val;
		
		System.out.printf("Toplam:%d%n", total);
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
 	Sınıf Çalışması: Klavyeden sıfır girilene kadar alınan sayılardan pozitif olanlarının ve negatif olanlarının ayrı 
 	ayrı sayılarını ve toplamlarını bulan programı yazınız. Programın mesajlarına ilişkin örnekler şunlardır:
 	
 	Girilen 3 tane pozitif sayının toplamı: 45
 	Girilen 4 tane negatif sayının toplamı: -56
 	
 	Girilen 3 tane pozitif sayının toplamı: 45
 	Hiç negatif sayı girmediniz
 	
 	Hiç pozitif sayı girmediniz
 	Girilen 4 tane negatif sayının toplamı: -56
 	
 	Hiç pozitif sayı girmediniz
 	Hiç negatif sayı girmediniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		PosNegCountTotalApp.run();				
	}
}

class PosNegCountTotalApp {
	public static void printPosStatus(int count, int sum)
	{
		if (count != 0)
			System.out.printf("Girilen %d tane pozitif sayının toplamı:%d%n", count, sum);
		else
			System.out.println("Hiç pozitif sayı girmediniz");
	}
	
	public static void printNegStatus(int count, int sum)
	{
		if (count != 0)
			System.out.printf("Girilen %d tane negatif sayının toplamı:%d%n", count, sum);
		else
			System.out.println("Hiç negatif sayı girmediniz");
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int posSum, negSum, posCount, negCount;
		int val;
		
		posSum = negSum = posCount = negCount = 0;
		
		System.out.println("Sayıları girmeye başlayınız:");
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0)
			if (val > 0) {
				posSum += val;
				++posCount;
			}
			else {
				negSum += val;
				++negCount;
			}		
		
		printPosStatus(posCount, posSum);
		printNegStatus(negCount, negSum);
	}
}



/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/

